// ******************************************************************
// *
// *    .,-:::::    .,::      .::::::::.    .,::      .:
// *  ,;;;'````'    `;;;,  .,;;  ;;;'';;'   `;;;,  .,;;
// *  [[[             '[[,,[['   [[[__[[\.    '[[,,[['
// *  $$$              Y$$$P     $$""""Y$$     Y$$$P
// *  `88bo,__,o,    oP"``"Yo,  _88o,,od8P   oP"``"Yo,
// *    "YUMMMMMP",m"       "Mm,""YUMMMP" ,m"       "Mm,
// *
// *   Cxbx->Win32->CxbxKrnl->EmuKrnl.cpp
// *
// *  This file is part of the Cxbx project.
// *
// *  Cxbx and Cxbe are free software; you can redistribute them
// *  and/or modify them under the terms of the GNU General Public
// *  License as published by the Free Software Foundation; either
// *  version 2 of the license, or (at your option) any later version.
// *
// *  This program is distributed in the hope that it will be useful,
// *  but WITHOUT ANY WARRANTY; without even the implied warranty of
// *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// *  GNU General Public License for more details.
// *
// *  You should have recieved a copy of the GNU General Public License
// *  along with this program; see the file COPYING.
// *  If not, write to the Free Software Foundation, Inc.,
// *  59 Temple Place - Suite 330, Bostom, MA 02111-1307, USA.
// *
// *  (c) 2002-2003 Aaron Robinson <caustik@caustik.com>
// *
// *  All rights reserved
// *
// ******************************************************************
#define _CXBXKRNL_INTERNAL
#define _XBOXKRNL_DEFEXTRN_

// prevent name collisions
namespace xboxkrnl
{
    #include <xboxkrnl/xboxkrnl.h>
};

#include <cstdio>
#include <cctype>
#include <clocale>
#include <process.h>

// prevent name collisions
namespace NtDll
{
    #include "EmuNtDll.h"
};

#include "CxbxKrnl.h"
#include "Logging.h"
#include "Emu.h"
#include "EmuFS.h"
#include "EmuFile.h"
#include "EmuAlloc.h"
#include "EmuXTL.h"
#include "ResourceTracker.h"

#pragma warning(disable:4005) // Ignore redefined status values
#include <ntstatus.h>
#pragma warning(default:4005)

// PsCreateSystemThread proxy parameters
typedef struct _PCSTProxyParam
{
    IN PVOID  StartContext1;
    IN PVOID  StartContext2;
    IN PVOID  StartRoutine;
    IN BOOL   StartSuspended;
    IN HANDLE hStartedEvent;
}
PCSTProxyParam;

// Global Variable(s)
extern PVOID g_pfnThreadNotification[16] = { NULL };
extern int g_iThreadNotificationCount = 0;
PVOID g_pPersistedData = NULL;

// A critical section containing the PC and Xbox equivalent
struct INTERNAL_CRITICAL_SECTION
{
	xboxkrnl::PRTL_CRITICAL_SECTION XboxCriticalSection;
	NtDll::_RTL_CRITICAL_SECTION NativeCriticalSection;
};

struct NativeObjectAttributes {
	wchar_t wszObjectName[160];
	NtDll::UNICODE_STRING    NtUnicodeString;
	NtDll::OBJECT_ATTRIBUTES NtObjAttr;
	// This is what should be passed on to Windows
	// after CxbxObjectAttributesToNT() has been called :
	NtDll::POBJECT_ATTRIBUTES NtObjAttrPtr;
};

#define MAX_XBOX_CRITICAL_SECTIONS 1024
INTERNAL_CRITICAL_SECTION GlobalCriticalSections[MAX_XBOX_CRITICAL_SECTIONS] = {0};

void InitializeSectionStructures(void)
{
	ZeroMemory(GlobalCriticalSections, sizeof(GlobalCriticalSections));
}

int FindCriticalSection(xboxkrnl::PRTL_CRITICAL_SECTION CriticalSection)
{
	int FreeSection = -1;

	int iSection = 0;
	for (iSection = 0; iSection < MAX_XBOX_CRITICAL_SECTIONS; ++iSection)
	{
		if (GlobalCriticalSections[iSection].XboxCriticalSection == CriticalSection)
		{
			FreeSection = iSection;
			break;
		}
		else if (FreeSection < 0 && GlobalCriticalSections[iSection].XboxCriticalSection == NULL)
		{
			FreeSection = iSection;
		}
	}

	if (FreeSection < 0)
	{
		EmuWarning("Too many critical sections in use!\n");
	}

	return FreeSection;
}

static CHAR* NtStatusToString ( IN NTSTATUS Status )
{
	#define _CASE(s) case s: return #s;

    switch(Status)
    {
    _CASE(STATUS_SUCCESS);
	_CASE(STATUS_WAIT_1);
	_CASE(STATUS_WAIT_2);
	_CASE(STATUS_WAIT_3);
	_CASE(STATUS_WAIT_63);
	_CASE(STATUS_ABANDONED_WAIT_0);
	_CASE(STATUS_ABANDONED_WAIT_63);
	_CASE(STATUS_USER_APC);
	_CASE(STATUS_KERNEL_APC);
	_CASE(STATUS_ALERTED);
	_CASE(STATUS_TIMEOUT);
	_CASE(STATUS_PENDING);
	_CASE(STATUS_REPARSE);
	_CASE(STATUS_MORE_ENTRIES);
	_CASE(STATUS_NOT_ALL_ASSIGNED);
	_CASE(STATUS_SOME_NOT_MAPPED);
	_CASE(STATUS_OPLOCK_BREAK_IN_PROGRESS);
	_CASE(STATUS_VOLUME_MOUNTED);
	_CASE(STATUS_RXACT_COMMITTED);
	_CASE(STATUS_NOTIFY_CLEANUP);
	_CASE(STATUS_NOTIFY_ENUM_DIR);
	_CASE(STATUS_NO_QUOTAS_FOR_ACCOUNT);
	_CASE(STATUS_PRIMARY_TRANSPORT_CONNECT_FAILED);
	_CASE(STATUS_PAGE_FAULT_TRANSITION);
	_CASE(STATUS_PAGE_FAULT_DEMAND_ZERO);
	_CASE(STATUS_PAGE_FAULT_COPY_ON_WRITE);
	_CASE(STATUS_PAGE_FAULT_GUARD_PAGE);
	_CASE(STATUS_PAGE_FAULT_PAGING_FILE);
	_CASE(STATUS_CACHE_PAGE_LOCKED);
	_CASE(STATUS_CRASH_DUMP);
	_CASE(STATUS_BUFFER_ALL_ZEROS);
	_CASE(STATUS_REPARSE_OBJECT);
	_CASE(STATUS_RESOURCE_REQUIREMENTS_CHANGED);
	_CASE(STATUS_TRANSLATION_COMPLETE);
	_CASE(STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY);
	_CASE(DBG_EXCEPTION_HANDLED);
	_CASE(DBG_CONTINUE);
	_CASE(STATUS_OBJECT_NAME_EXISTS);
	_CASE(STATUS_THREAD_WAS_SUSPENDED);
	_CASE(STATUS_WORKING_SET_LIMIT_RANGE);
	_CASE(STATUS_IMAGE_NOT_AT_BASE);
	_CASE(STATUS_RXACT_STATE_CREATED);
	_CASE(STATUS_SEGMENT_NOTIFICATION);
	_CASE(STATUS_LOCAL_USER_SESSION_KEY);
	_CASE(STATUS_BAD_CURRENT_DIRECTORY);
	_CASE(STATUS_SERIAL_MORE_WRITES);
	_CASE(STATUS_REGISTRY_RECOVERED);
	_CASE(STATUS_FT_READ_RECOVERY_FROM_BACKUP);
	_CASE(STATUS_FT_WRITE_RECOVERY);
	_CASE(STATUS_SERIAL_COUNTER_TIMEOUT);
	_CASE(STATUS_NULL_LM_PASSWORD);
	_CASE(STATUS_IMAGE_MACHINE_TYPE_MISMATCH);
	_CASE(STATUS_RECEIVE_PARTIAL);
	_CASE(STATUS_RECEIVE_EXPEDITED);
	_CASE(STATUS_RECEIVE_PARTIAL_EXPEDITED);
	_CASE(STATUS_EVENT_DONE);
	_CASE(STATUS_EVENT_PENDING);
	_CASE(STATUS_CHECKING_FILE_SYSTEM);
	_CASE(STATUS_FATAL_APP_EXIT);
	_CASE(STATUS_PREDEFINED_HANDLE);
	_CASE(STATUS_WAS_UNLOCKED);
	_CASE(STATUS_SERVICE_NOTIFICATION);
	_CASE(STATUS_WAS_LOCKED);
	_CASE(STATUS_LOG_HARD_ERROR);
	_CASE(STATUS_ALREADY_WIN32);
	_CASE(STATUS_WX86_UNSIMULATE);
	_CASE(STATUS_WX86_CONTINUE);
	_CASE(STATUS_WX86_SINGLE_STEP);
	_CASE(STATUS_WX86_BREAKPOINT);
	_CASE(STATUS_WX86_EXCEPTION_CONTINUE);
	_CASE(STATUS_WX86_EXCEPTION_LASTCHANCE);
	_CASE(STATUS_WX86_EXCEPTION_CHAIN);
	_CASE(STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE);
	_CASE(STATUS_NO_YIELD_PERFORMED);
	_CASE(STATUS_TIMER_RESUME_IGNORED);
	_CASE(STATUS_ARBITRATION_UNHANDLED);
	_CASE(STATUS_CARDBUS_NOT_SUPPORTED);
	_CASE(STATUS_WX86_CREATEWX86TIB);
	_CASE(STATUS_MP_PROCESSOR_MISMATCH);
	_CASE(DBG_REPLY_LATER);
	_CASE(DBG_UNABLE_TO_PROVIDE_HANDLE);
	_CASE(DBG_TERMINATE_THREAD);
	_CASE(DBG_TERMINATE_PROCESS);
	_CASE(DBG_CONTROL_C);
	_CASE(DBG_PRINTEXCEPTION_C);
	_CASE(DBG_RIPEXCEPTION);
	_CASE(DBG_CONTROL_BREAK);
	_CASE(STATUS_GUARD_PAGE_VIOLATION);
	_CASE(STATUS_DATATYPE_MISALIGNMENT);
	_CASE(STATUS_BREAKPOINT);
	_CASE(STATUS_SINGLE_STEP);
	_CASE(STATUS_BUFFER_OVERFLOW);
	_CASE(STATUS_NO_MORE_FILES);
	_CASE(STATUS_WAKE_SYSTEM_DEBUGGER);
	_CASE(STATUS_HANDLES_CLOSED);
	_CASE(STATUS_NO_INHERITANCE);
	_CASE(STATUS_GUID_SUBSTITUTION_MADE);
	_CASE(STATUS_PARTIAL_COPY);
	_CASE(STATUS_DEVICE_PAPER_EMPTY);
	_CASE(STATUS_DEVICE_POWERED_OFF);
	_CASE(STATUS_DEVICE_OFF_LINE);
	_CASE(STATUS_DEVICE_BUSY);
	_CASE(STATUS_NO_MORE_EAS);
	_CASE(STATUS_INVALID_EA_NAME);
	_CASE(STATUS_EA_LIST_INCONSISTENT);
	_CASE(STATUS_INVALID_EA_FLAG);
	_CASE(STATUS_VERIFY_REQUIRED);
	_CASE(STATUS_EXTRANEOUS_INFORMATION);
	_CASE(STATUS_RXACT_COMMIT_NECESSARY);
	_CASE(STATUS_NO_MORE_ENTRIES);
	_CASE(STATUS_FILEMARK_DETECTED);
	_CASE(STATUS_MEDIA_CHANGED);
	_CASE(STATUS_BUS_RESET);
	_CASE(STATUS_END_OF_MEDIA);
	_CASE(STATUS_BEGINNING_OF_MEDIA);
	_CASE(STATUS_MEDIA_CHECK);
	_CASE(STATUS_SETMARK_DETECTED);
	_CASE(STATUS_NO_DATA_DETECTED);
	_CASE(STATUS_REDIRECTOR_HAS_OPEN_HANDLES);
	_CASE(STATUS_SERVER_HAS_OPEN_HANDLES);
	_CASE(STATUS_ALREADY_DISCONNECTED);
	_CASE(STATUS_LONGJUMP);
	_CASE(DBG_EXCEPTION_NOT_HANDLED);
	_CASE(STATUS_UNSUCCESSFUL);
	_CASE(STATUS_NOT_IMPLEMENTED);
	_CASE(STATUS_INVALID_INFO_CLASS);
	_CASE(STATUS_INFO_LENGTH_MISMATCH);
	_CASE(STATUS_ACCESS_VIOLATION);
	_CASE(STATUS_IN_PAGE_ERROR);
	_CASE(STATUS_PAGEFILE_QUOTA);
	_CASE(STATUS_INVALID_HANDLE);
	_CASE(STATUS_BAD_INITIAL_STACK);
	_CASE(STATUS_BAD_INITIAL_PC);
	_CASE(STATUS_INVALID_CID);
	_CASE(STATUS_TIMER_NOT_CANCELED);
	_CASE(STATUS_INVALID_PARAMETER);
	_CASE(STATUS_NO_SUCH_DEVICE);
	_CASE(STATUS_NO_SUCH_FILE);
	_CASE(STATUS_INVALID_DEVICE_REQUEST);
	_CASE(STATUS_END_OF_FILE);
	_CASE(STATUS_WRONG_VOLUME);
	_CASE(STATUS_NO_MEDIA_IN_DEVICE);
	_CASE(STATUS_UNRECOGNIZED_MEDIA);
	_CASE(STATUS_NONEXISTENT_SECTOR);
	_CASE(STATUS_MORE_PROCESSING_REQUIRED);
	_CASE(STATUS_NO_MEMORY);
	_CASE(STATUS_CONFLICTING_ADDRESSES);
	_CASE(STATUS_NOT_MAPPED_VIEW);
	_CASE(STATUS_UNABLE_TO_FREE_VM);
	_CASE(STATUS_UNABLE_TO_DELETE_SECTION);
	_CASE(STATUS_INVALID_SYSTEM_SERVICE);
	_CASE(STATUS_ILLEGAL_INSTRUCTION);
	_CASE(STATUS_INVALID_LOCK_SEQUENCE);
	_CASE(STATUS_INVALID_VIEW_SIZE);
	_CASE(STATUS_INVALID_FILE_FOR_SECTION);
	_CASE(STATUS_ALREADY_COMMITTED);
	_CASE(STATUS_ACCESS_DENIED);
	_CASE(STATUS_BUFFER_TOO_SMALL);
	_CASE(STATUS_OBJECT_TYPE_MISMATCH);
	_CASE(STATUS_NONCONTINUABLE_EXCEPTION);
	_CASE(STATUS_INVALID_DISPOSITION);
	_CASE(STATUS_UNWIND);
	_CASE(STATUS_BAD_STACK);
	_CASE(STATUS_INVALID_UNWIND_TARGET);
	_CASE(STATUS_NOT_LOCKED);
	_CASE(STATUS_PARITY_ERROR);
	_CASE(STATUS_UNABLE_TO_DECOMMIT_VM);
	_CASE(STATUS_NOT_COMMITTED);
	_CASE(STATUS_INVALID_PORT_ATTRIBUTES);
	_CASE(STATUS_PORT_MESSAGE_TOO_LONG);
	_CASE(STATUS_INVALID_PARAMETER_MIX);
	_CASE(STATUS_INVALID_QUOTA_LOWER);
	_CASE(STATUS_DISK_CORRUPT_ERROR);
	_CASE(STATUS_OBJECT_NAME_INVALID);
	_CASE(STATUS_OBJECT_NAME_NOT_FOUND);
	_CASE(STATUS_OBJECT_NAME_COLLISION);
	_CASE(STATUS_PORT_DISCONNECTED);
	_CASE(STATUS_DEVICE_ALREADY_ATTACHED);
	_CASE(STATUS_OBJECT_PATH_INVALID);
	_CASE(STATUS_OBJECT_PATH_NOT_FOUND);
	_CASE(STATUS_OBJECT_PATH_SYNTAX_BAD);
	_CASE(STATUS_DATA_OVERRUN);
	_CASE(STATUS_DATA_LATE_ERROR);
	_CASE(STATUS_DATA_ERROR);
	_CASE(STATUS_CRC_ERROR);
	_CASE(STATUS_SECTION_TOO_BIG);
	_CASE(STATUS_PORT_CONNECTION_REFUSED);
	_CASE(STATUS_INVALID_PORT_HANDLE);
	_CASE(STATUS_SHARING_VIOLATION);
	_CASE(STATUS_QUOTA_EXCEEDED);
	_CASE(STATUS_INVALID_PAGE_PROTECTION);
	_CASE(STATUS_MUTANT_NOT_OWNED);
	_CASE(STATUS_SEMAPHORE_LIMIT_EXCEEDED);
	_CASE(STATUS_PORT_ALREADY_SET);
	_CASE(STATUS_SECTION_NOT_IMAGE);
	_CASE(STATUS_SUSPEND_COUNT_EXCEEDED);
	_CASE(STATUS_THREAD_IS_TERMINATING);
	_CASE(STATUS_BAD_WORKING_SET_LIMIT);
	_CASE(STATUS_INCOMPATIBLE_FILE_MAP);
	_CASE(STATUS_SECTION_PROTECTION);
	_CASE(STATUS_EAS_NOT_SUPPORTED);
	_CASE(STATUS_EA_TOO_LARGE);
	_CASE(STATUS_NONEXISTENT_EA_ENTRY);
	_CASE(STATUS_NO_EAS_ON_FILE);
	_CASE(STATUS_EA_CORRUPT_ERROR);
	_CASE(STATUS_FILE_LOCK_CONFLICT);
	_CASE(STATUS_LOCK_NOT_GRANTED);
	_CASE(STATUS_DELETE_PENDING);
	_CASE(STATUS_CTL_FILE_NOT_SUPPORTED);
	_CASE(STATUS_UNKNOWN_REVISION);
	_CASE(STATUS_REVISION_MISMATCH);
	_CASE(STATUS_INVALID_OWNER);
	_CASE(STATUS_INVALID_PRIMARY_GROUP);
	_CASE(STATUS_NO_IMPERSONATION_TOKEN);
	_CASE(STATUS_CANT_DISABLE_MANDATORY);
	_CASE(STATUS_NO_LOGON_SERVERS);
	_CASE(STATUS_NO_SUCH_LOGON_SESSION);
	_CASE(STATUS_NO_SUCH_PRIVILEGE);
	_CASE(STATUS_PRIVILEGE_NOT_HELD);
	_CASE(STATUS_INVALID_ACCOUNT_NAME);
	_CASE(STATUS_USER_EXISTS);
	_CASE(STATUS_NO_SUCH_USER);
	_CASE(STATUS_GROUP_EXISTS);
	_CASE(STATUS_NO_SUCH_GROUP);
	_CASE(STATUS_MEMBER_IN_GROUP);
	_CASE(STATUS_MEMBER_NOT_IN_GROUP);
	_CASE(STATUS_LAST_ADMIN);
	_CASE(STATUS_WRONG_PASSWORD);
	_CASE(STATUS_ILL_FORMED_PASSWORD);
	_CASE(STATUS_PASSWORD_RESTRICTION);
	_CASE(STATUS_LOGON_FAILURE);
	_CASE(STATUS_ACCOUNT_RESTRICTION);
	_CASE(STATUS_INVALID_LOGON_HOURS);
	_CASE(STATUS_INVALID_WORKSTATION);
	_CASE(STATUS_PASSWORD_EXPIRED);
	_CASE(STATUS_ACCOUNT_DISABLED);
	_CASE(STATUS_NONE_MAPPED);
	_CASE(STATUS_TOO_MANY_LUIDS_REQUESTED);
	_CASE(STATUS_LUIDS_EXHAUSTED);
	_CASE(STATUS_INVALID_SUB_AUTHORITY);
	_CASE(STATUS_INVALID_ACL);
	_CASE(STATUS_INVALID_SID);
	_CASE(STATUS_INVALID_SECURITY_DESCR);
	_CASE(STATUS_PROCEDURE_NOT_FOUND);
	_CASE(STATUS_INVALID_IMAGE_FORMAT);
	_CASE(STATUS_NO_TOKEN);
	_CASE(STATUS_BAD_INHERITANCE_ACL);
	_CASE(STATUS_RANGE_NOT_LOCKED);
	_CASE(STATUS_DISK_FULL);
	_CASE(STATUS_SERVER_DISABLED);
	_CASE(STATUS_SERVER_NOT_DISABLED);
	_CASE(STATUS_TOO_MANY_GUIDS_REQUESTED);
	_CASE(STATUS_GUIDS_EXHAUSTED);
	_CASE(STATUS_INVALID_ID_AUTHORITY);
	_CASE(STATUS_AGENTS_EXHAUSTED);
	_CASE(STATUS_INVALID_VOLUME_LABEL);
	_CASE(STATUS_SECTION_NOT_EXTENDED);
	_CASE(STATUS_NOT_MAPPED_DATA);
	_CASE(STATUS_RESOURCE_DATA_NOT_FOUND);
	_CASE(STATUS_RESOURCE_TYPE_NOT_FOUND);
	_CASE(STATUS_RESOURCE_NAME_NOT_FOUND);
	_CASE(STATUS_ARRAY_BOUNDS_EXCEEDED);
	_CASE(STATUS_FLOAT_DENORMAL_OPERAND);
	_CASE(STATUS_FLOAT_DIVIDE_BY_ZERO);
	_CASE(STATUS_FLOAT_INEXACT_RESULT);
	_CASE(STATUS_FLOAT_INVALID_OPERATION);
	_CASE(STATUS_FLOAT_OVERFLOW);
	_CASE(STATUS_FLOAT_STACK_CHECK);
	_CASE(STATUS_FLOAT_UNDERFLOW);
	_CASE(STATUS_INTEGER_DIVIDE_BY_ZERO);
	_CASE(STATUS_INTEGER_OVERFLOW);
	_CASE(STATUS_PRIVILEGED_INSTRUCTION);
	_CASE(STATUS_TOO_MANY_PAGING_FILES);
	_CASE(STATUS_FILE_INVALID);
	_CASE(STATUS_ALLOTTED_SPACE_EXCEEDED);
	_CASE(STATUS_INSUFFICIENT_RESOURCES);
	_CASE(STATUS_DFS_EXIT_PATH_FOUND);
	_CASE(STATUS_DEVICE_DATA_ERROR);
	_CASE(STATUS_DEVICE_NOT_CONNECTED);
	_CASE(STATUS_DEVICE_POWER_FAILURE);
	_CASE(STATUS_FREE_VM_NOT_AT_BASE);
	_CASE(STATUS_MEMORY_NOT_ALLOCATED);
	_CASE(STATUS_WORKING_SET_QUOTA);
	_CASE(STATUS_MEDIA_WRITE_PROTECTED);
	_CASE(STATUS_DEVICE_NOT_READY);
	_CASE(STATUS_INVALID_GROUP_ATTRIBUTES);
	_CASE(STATUS_BAD_IMPERSONATION_LEVEL);
	_CASE(STATUS_CANT_OPEN_ANONYMOUS);
	_CASE(STATUS_BAD_VALIDATION_CLASS);
	_CASE(STATUS_BAD_TOKEN_TYPE);
	_CASE(STATUS_BAD_MASTER_BOOT_RECORD);
	_CASE(STATUS_INSTRUCTION_MISALIGNMENT);
	_CASE(STATUS_INSTANCE_NOT_AVAILABLE);
	_CASE(STATUS_PIPE_NOT_AVAILABLE);
	_CASE(STATUS_INVALID_PIPE_STATE);
	_CASE(STATUS_PIPE_BUSY);
	_CASE(STATUS_ILLEGAL_FUNCTION);
	_CASE(STATUS_PIPE_DISCONNECTED);
	_CASE(STATUS_PIPE_CLOSING);
	_CASE(STATUS_PIPE_CONNECTED);
	_CASE(STATUS_PIPE_LISTENING);
	_CASE(STATUS_INVALID_READ_MODE);
	_CASE(STATUS_IO_TIMEOUT);
	_CASE(STATUS_FILE_FORCED_CLOSED);
	_CASE(STATUS_PROFILING_NOT_STARTED);
	_CASE(STATUS_PROFILING_NOT_STOPPED);
	_CASE(STATUS_COULD_NOT_INTERPRET);
	_CASE(STATUS_FILE_IS_A_DIRECTORY);
	_CASE(STATUS_NOT_SUPPORTED);
	_CASE(STATUS_REMOTE_NOT_LISTENING);
	_CASE(STATUS_DUPLICATE_NAME);
	_CASE(STATUS_BAD_NETWORK_PATH);
	_CASE(STATUS_NETWORK_BUSY);
	_CASE(STATUS_DEVICE_DOES_NOT_EXIST);
	_CASE(STATUS_TOO_MANY_COMMANDS);
	_CASE(STATUS_ADAPTER_HARDWARE_ERROR);
	_CASE(STATUS_INVALID_NETWORK_RESPONSE);
	_CASE(STATUS_UNEXPECTED_NETWORK_ERROR);
	_CASE(STATUS_BAD_REMOTE_ADAPTER);
	_CASE(STATUS_PRINT_QUEUE_FULL);
	_CASE(STATUS_NO_SPOOL_SPACE);
	_CASE(STATUS_PRINT_CANCELLED);
	_CASE(STATUS_NETWORK_NAME_DELETED);
	_CASE(STATUS_NETWORK_ACCESS_DENIED);
	_CASE(STATUS_BAD_DEVICE_TYPE);
	_CASE(STATUS_BAD_NETWORK_NAME);
	_CASE(STATUS_TOO_MANY_NAMES);
	_CASE(STATUS_TOO_MANY_SESSIONS);
	_CASE(STATUS_SHARING_PAUSED);
	_CASE(STATUS_REQUEST_NOT_ACCEPTED);
	_CASE(STATUS_REDIRECTOR_PAUSED);
	_CASE(STATUS_NET_WRITE_FAULT);
	_CASE(STATUS_PROFILING_AT_LIMIT);
	_CASE(STATUS_NOT_SAME_DEVICE);
	_CASE(STATUS_FILE_RENAMED);
	_CASE(STATUS_VIRTUAL_CIRCUIT_CLOSED);
	_CASE(STATUS_NO_SECURITY_ON_OBJECT);
	_CASE(STATUS_CANT_WAIT);
	_CASE(STATUS_PIPE_EMPTY);
	_CASE(STATUS_CANT_ACCESS_DOMAIN_INFO);
	_CASE(STATUS_CANT_TERMINATE_SELF);
	_CASE(STATUS_INVALID_SERVER_STATE);
	_CASE(STATUS_INVALID_DOMAIN_STATE);
	_CASE(STATUS_INVALID_DOMAIN_ROLE);
	_CASE(STATUS_NO_SUCH_DOMAIN);
	_CASE(STATUS_DOMAIN_EXISTS);
	_CASE(STATUS_DOMAIN_LIMIT_EXCEEDED);
	_CASE(STATUS_OPLOCK_NOT_GRANTED);
	_CASE(STATUS_INVALID_OPLOCK_PROTOCOL);
	_CASE(STATUS_INTERNAL_DB_CORRUPTION);
	_CASE(STATUS_INTERNAL_ERROR);
	_CASE(STATUS_GENERIC_NOT_MAPPED);
	_CASE(STATUS_BAD_DESCRIPTOR_FORMAT);
	_CASE(STATUS_INVALID_USER_BUFFER);
	_CASE(STATUS_UNEXPECTED_IO_ERROR);
	_CASE(STATUS_UNEXPECTED_MM_CREATE_ERR);
	_CASE(STATUS_UNEXPECTED_MM_MAP_ERROR);
	_CASE(STATUS_UNEXPECTED_MM_EXTEND_ERR);
	_CASE(STATUS_NOT_LOGON_PROCESS);
	_CASE(STATUS_LOGON_SESSION_EXISTS);
	_CASE(STATUS_INVALID_PARAMETER_1);
	_CASE(STATUS_INVALID_PARAMETER_2);
	_CASE(STATUS_INVALID_PARAMETER_3);
	_CASE(STATUS_INVALID_PARAMETER_4);
	_CASE(STATUS_INVALID_PARAMETER_5);
	_CASE(STATUS_INVALID_PARAMETER_6);
	_CASE(STATUS_INVALID_PARAMETER_7);
	_CASE(STATUS_INVALID_PARAMETER_8);
	_CASE(STATUS_INVALID_PARAMETER_9);
	_CASE(STATUS_INVALID_PARAMETER_10);
	_CASE(STATUS_INVALID_PARAMETER_11);
	_CASE(STATUS_INVALID_PARAMETER_12);
	_CASE(STATUS_REDIRECTOR_NOT_STARTED);
	_CASE(STATUS_REDIRECTOR_STARTED);
	_CASE(STATUS_STACK_OVERFLOW);
	_CASE(STATUS_NO_SUCH_PACKAGE);
	_CASE(STATUS_BAD_FUNCTION_TABLE);
	_CASE(STATUS_VARIABLE_NOT_FOUND);
	_CASE(STATUS_DIRECTORY_NOT_EMPTY);
	_CASE(STATUS_FILE_CORRUPT_ERROR);
	_CASE(STATUS_NOT_A_DIRECTORY);
	_CASE(STATUS_BAD_LOGON_SESSION_STATE);
	_CASE(STATUS_LOGON_SESSION_COLLISION);
	_CASE(STATUS_NAME_TOO_LONG);
	_CASE(STATUS_FILES_OPEN);
	_CASE(STATUS_CONNECTION_IN_USE);
	_CASE(STATUS_MESSAGE_NOT_FOUND);
	_CASE(STATUS_PROCESS_IS_TERMINATING);
	_CASE(STATUS_INVALID_LOGON_TYPE);
	_CASE(STATUS_NO_GUID_TRANSLATION);
	_CASE(STATUS_CANNOT_IMPERSONATE);
	_CASE(STATUS_IMAGE_ALREADY_LOADED);
	_CASE(STATUS_ABIOS_NOT_PRESENT);
	_CASE(STATUS_ABIOS_LID_NOT_EXIST);
	_CASE(STATUS_ABIOS_LID_ALREADY_OWNED);
	_CASE(STATUS_ABIOS_NOT_LID_OWNER);
	_CASE(STATUS_ABIOS_INVALID_COMMAND);
	_CASE(STATUS_ABIOS_INVALID_LID);
	_CASE(STATUS_ABIOS_SELECTOR_NOT_AVAILABLE);
	_CASE(STATUS_ABIOS_INVALID_SELECTOR);
	_CASE(STATUS_NO_LDT);
	_CASE(STATUS_INVALID_LDT_SIZE);
	_CASE(STATUS_INVALID_LDT_OFFSET);
	_CASE(STATUS_INVALID_LDT_DESCRIPTOR);
	_CASE(STATUS_INVALID_IMAGE_NE_FORMAT);
	_CASE(STATUS_RXACT_INVALID_STATE);
	_CASE(STATUS_RXACT_COMMIT_FAILURE);
	_CASE(STATUS_MAPPED_FILE_SIZE_ZERO);
	_CASE(STATUS_TOO_MANY_OPENED_FILES);
	_CASE(STATUS_CANCELLED);
	_CASE(STATUS_CANNOT_DELETE);
	_CASE(STATUS_INVALID_COMPUTER_NAME);
	_CASE(STATUS_FILE_DELETED);
	_CASE(STATUS_SPECIAL_ACCOUNT);
	_CASE(STATUS_SPECIAL_GROUP);
	_CASE(STATUS_SPECIAL_USER);
	_CASE(STATUS_MEMBERS_PRIMARY_GROUP);
	_CASE(STATUS_FILE_CLOSED);
	_CASE(STATUS_TOO_MANY_THREADS);
	_CASE(STATUS_THREAD_NOT_IN_PROCESS);
	_CASE(STATUS_TOKEN_ALREADY_IN_USE);
	_CASE(STATUS_PAGEFILE_QUOTA_EXCEEDED);
	_CASE(STATUS_COMMITMENT_LIMIT);
	_CASE(STATUS_INVALID_IMAGE_LE_FORMAT);
	_CASE(STATUS_INVALID_IMAGE_NOT_MZ);
	_CASE(STATUS_INVALID_IMAGE_PROTECT);
	_CASE(STATUS_INVALID_IMAGE_WIN_16);
	_CASE(STATUS_LOGON_SERVER_CONFLICT);
	_CASE(STATUS_TIME_DIFFERENCE_AT_DC);
	_CASE(STATUS_SYNCHRONIZATION_REQUIRED);
	_CASE(STATUS_DLL_NOT_FOUND);
	_CASE(STATUS_OPEN_FAILED);
	_CASE(STATUS_IO_PRIVILEGE_FAILED);
	_CASE(STATUS_ORDINAL_NOT_FOUND);
	_CASE(STATUS_ENTRYPOINT_NOT_FOUND);
	_CASE(STATUS_CONTROL_C_EXIT);
	_CASE(STATUS_LOCAL_DISCONNECT);
	_CASE(STATUS_REMOTE_DISCONNECT);
	_CASE(STATUS_REMOTE_RESOURCES);
	_CASE(STATUS_LINK_FAILED);
	_CASE(STATUS_LINK_TIMEOUT);
	_CASE(STATUS_INVALID_CONNECTION);
	_CASE(STATUS_INVALID_ADDRESS);
	_CASE(STATUS_DLL_INIT_FAILED);
	_CASE(STATUS_MISSING_SYSTEMFILE);
	_CASE(STATUS_UNHANDLED_EXCEPTION);
	_CASE(STATUS_APP_INIT_FAILURE);
	_CASE(STATUS_PAGEFILE_CREATE_FAILED);
	_CASE(STATUS_NO_PAGEFILE);
	_CASE(STATUS_INVALID_LEVEL);
	_CASE(STATUS_WRONG_PASSWORD_CORE);
	_CASE(STATUS_ILLEGAL_FLOAT_CONTEXT);
	_CASE(STATUS_PIPE_BROKEN);
	_CASE(STATUS_REGISTRY_CORRUPT);
	_CASE(STATUS_REGISTRY_IO_FAILED);
	_CASE(STATUS_NO_EVENT_PAIR);
	_CASE(STATUS_UNRECOGNIZED_VOLUME);
	_CASE(STATUS_SERIAL_NO_DEVICE_INITED);
	_CASE(STATUS_NO_SUCH_ALIAS);
	_CASE(STATUS_MEMBER_NOT_IN_ALIAS);
	_CASE(STATUS_MEMBER_IN_ALIAS);
	_CASE(STATUS_ALIAS_EXISTS);
	_CASE(STATUS_LOGON_NOT_GRANTED);
	_CASE(STATUS_TOO_MANY_SECRETS);
	_CASE(STATUS_SECRET_TOO_LONG);
	_CASE(STATUS_INTERNAL_DB_ERROR);
	_CASE(STATUS_FULLSCREEN_MODE);
	_CASE(STATUS_TOO_MANY_CONTEXT_IDS);
	_CASE(STATUS_LOGON_TYPE_NOT_GRANTED);
	_CASE(STATUS_NOT_REGISTRY_FILE);
	_CASE(STATUS_NT_CROSS_ENCRYPTION_REQUIRED);
	_CASE(STATUS_DOMAIN_CTRLR_CONFIG_ERROR);
	_CASE(STATUS_FT_MISSING_MEMBER);
	_CASE(STATUS_ILL_FORMED_SERVICE_ENTRY);
	_CASE(STATUS_ILLEGAL_CHARACTER);
	_CASE(STATUS_UNMAPPABLE_CHARACTER);
	_CASE(STATUS_UNDEFINED_CHARACTER);
	_CASE(STATUS_FLOPPY_VOLUME);
	_CASE(STATUS_FLOPPY_ID_MARK_NOT_FOUND);
	_CASE(STATUS_FLOPPY_WRONG_CYLINDER);
	_CASE(STATUS_FLOPPY_UNKNOWN_ERROR);
	_CASE(STATUS_FLOPPY_BAD_REGISTERS);
	_CASE(STATUS_DISK_RECALIBRATE_FAILED);
	_CASE(STATUS_DISK_OPERATION_FAILED);
	_CASE(STATUS_DISK_RESET_FAILED);
	_CASE(STATUS_SHARED_IRQ_BUSY);
	_CASE(STATUS_FT_ORPHANING);
	_CASE(STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT);
	_CASE(STATUS_PARTITION_FAILURE);
	_CASE(STATUS_INVALID_BLOCK_LENGTH);
	_CASE(STATUS_DEVICE_NOT_PARTITIONED);
	_CASE(STATUS_UNABLE_TO_LOCK_MEDIA);
	_CASE(STATUS_UNABLE_TO_UNLOAD_MEDIA);
	_CASE(STATUS_EOM_OVERFLOW);
	_CASE(STATUS_NO_MEDIA);
	_CASE(STATUS_NO_SUCH_MEMBER);
	_CASE(STATUS_INVALID_MEMBER);
	_CASE(STATUS_KEY_DELETED);
	_CASE(STATUS_NO_LOG_SPACE);
	_CASE(STATUS_TOO_MANY_SIDS);
	_CASE(STATUS_LM_CROSS_ENCRYPTION_REQUIRED);
	_CASE(STATUS_KEY_HAS_CHILDREN);
	_CASE(STATUS_CHILD_MUST_BE_VOLATILE);
	_CASE(STATUS_DEVICE_CONFIGURATION_ERROR);
	_CASE(STATUS_DRIVER_INTERNAL_ERROR);
	_CASE(STATUS_INVALID_DEVICE_STATE);
	_CASE(STATUS_IO_DEVICE_ERROR);
	_CASE(STATUS_DEVICE_PROTOCOL_ERROR);
	_CASE(STATUS_BACKUP_CONTROLLER);
	_CASE(STATUS_LOG_FILE_FULL);
	_CASE(STATUS_TOO_LATE);
	_CASE(STATUS_NO_TRUST_LSA_SECRET);
	_CASE(STATUS_NO_TRUST_SAM_ACCOUNT);
	_CASE(STATUS_TRUSTED_DOMAIN_FAILURE);
	_CASE(STATUS_TRUSTED_RELATIONSHIP_FAILURE);
	_CASE(STATUS_EVENTLOG_FILE_CORRUPT);
	_CASE(STATUS_EVENTLOG_CANT_START);
	_CASE(STATUS_TRUST_FAILURE);
	_CASE(STATUS_MUTANT_LIMIT_EXCEEDED);
	_CASE(STATUS_NETLOGON_NOT_STARTED);
	_CASE(STATUS_ACCOUNT_EXPIRED);
	_CASE(STATUS_POSSIBLE_DEADLOCK);
	_CASE(STATUS_NETWORK_CREDENTIAL_CONFLICT);
	_CASE(STATUS_REMOTE_SESSION_LIMIT);
	_CASE(STATUS_EVENTLOG_FILE_CHANGED);
	_CASE(STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT);
	_CASE(STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT);
	_CASE(STATUS_NOLOGON_SERVER_TRUST_ACCOUNT);
	_CASE(STATUS_DOMAIN_TRUST_INCONSISTENT);
	_CASE(STATUS_FS_DRIVER_REQUIRED);
	_CASE(STATUS_NO_USER_SESSION_KEY);
	_CASE(STATUS_USER_SESSION_DELETED);
	_CASE(STATUS_RESOURCE_LANG_NOT_FOUND);
	_CASE(STATUS_INSUFF_SERVER_RESOURCES);
	_CASE(STATUS_INVALID_BUFFER_SIZE);
	_CASE(STATUS_INVALID_ADDRESS_COMPONENT);
	_CASE(STATUS_INVALID_ADDRESS_WILDCARD);
	_CASE(STATUS_TOO_MANY_ADDRESSES);
	_CASE(STATUS_ADDRESS_ALREADY_EXISTS);
	_CASE(STATUS_ADDRESS_CLOSED);
	_CASE(STATUS_CONNECTION_DISCONNECTED);
	_CASE(STATUS_CONNECTION_RESET);
	_CASE(STATUS_TOO_MANY_NODES);
	_CASE(STATUS_TRANSACTION_ABORTED);
	_CASE(STATUS_TRANSACTION_TIMED_OUT);
	_CASE(STATUS_TRANSACTION_NO_RELEASE);
	_CASE(STATUS_TRANSACTION_NO_MATCH);
	_CASE(STATUS_TRANSACTION_RESPONDED);
	_CASE(STATUS_TRANSACTION_INVALID_ID);
	_CASE(STATUS_TRANSACTION_INVALID_TYPE);
	_CASE(STATUS_NOT_SERVER_SESSION);
	_CASE(STATUS_NOT_CLIENT_SESSION);
	_CASE(STATUS_CANNOT_LOAD_REGISTRY_FILE);
	_CASE(STATUS_DEBUG_ATTACH_FAILED);
	_CASE(STATUS_SYSTEM_PROCESS_TERMINATED);
	_CASE(STATUS_DATA_NOT_ACCEPTED);
	_CASE(STATUS_NO_BROWSER_SERVERS_FOUND);
	_CASE(STATUS_VDM_HARD_ERROR);
	_CASE(STATUS_DRIVER_CANCEL_TIMEOUT);
	_CASE(STATUS_REPLY_MESSAGE_MISMATCH);
	_CASE(STATUS_MAPPED_ALIGNMENT);
	_CASE(STATUS_IMAGE_CHECKSUM_MISMATCH);
	_CASE(STATUS_LOST_WRITEBEHIND_DATA);
	_CASE(STATUS_CLIENT_SERVER_PARAMETERS_INVALID);
	_CASE(STATUS_PASSWORD_MUST_CHANGE);
	_CASE(STATUS_NOT_FOUND);
	_CASE(STATUS_NOT_TINY_STREAM);
	_CASE(STATUS_RECOVERY_FAILURE);
	_CASE(STATUS_STACK_OVERFLOW_READ);
	_CASE(STATUS_FAIL_CHECK);
	_CASE(STATUS_DUPLICATE_OBJECTID);
	_CASE(STATUS_OBJECTID_EXISTS);
	_CASE(STATUS_CONVERT_TO_LARGE);
	_CASE(STATUS_RETRY);
	_CASE(STATUS_FOUND_OUT_OF_SCOPE);
	_CASE(STATUS_ALLOCATE_BUCKET);
	_CASE(STATUS_PROPSET_NOT_FOUND);
	_CASE(STATUS_MARSHALL_OVERFLOW);
	_CASE(STATUS_INVALID_VARIANT);
	_CASE(STATUS_DOMAIN_CONTROLLER_NOT_FOUND);
	_CASE(STATUS_ACCOUNT_LOCKED_OUT);
	_CASE(STATUS_HANDLE_NOT_CLOSABLE);
	_CASE(STATUS_CONNECTION_REFUSED);
	_CASE(STATUS_GRACEFUL_DISCONNECT);
	_CASE(STATUS_ADDRESS_ALREADY_ASSOCIATED);
	_CASE(STATUS_ADDRESS_NOT_ASSOCIATED);
	_CASE(STATUS_CONNECTION_INVALID);
	_CASE(STATUS_CONNECTION_ACTIVE);
	_CASE(STATUS_NETWORK_UNREACHABLE);
	_CASE(STATUS_HOST_UNREACHABLE);
	_CASE(STATUS_PROTOCOL_UNREACHABLE);
	_CASE(STATUS_PORT_UNREACHABLE);
	_CASE(STATUS_REQUEST_ABORTED);
	_CASE(STATUS_CONNECTION_ABORTED);
	_CASE(STATUS_BAD_COMPRESSION_BUFFER);
	_CASE(STATUS_USER_MAPPED_FILE);
	_CASE(STATUS_AUDIT_FAILED);
	_CASE(STATUS_TIMER_RESOLUTION_NOT_SET);
	_CASE(STATUS_CONNECTION_COUNT_LIMIT);
	_CASE(STATUS_LOGIN_TIME_RESTRICTION);
	_CASE(STATUS_LOGIN_WKSTA_RESTRICTION);
	_CASE(STATUS_IMAGE_MP_UP_MISMATCH);
	_CASE(STATUS_INSUFFICIENT_LOGON_INFO);
	_CASE(STATUS_BAD_DLL_ENTRYPOINT);
	_CASE(STATUS_BAD_SERVICE_ENTRYPOINT);
	_CASE(STATUS_LPC_REPLY_LOST);
	_CASE(STATUS_IP_ADDRESS_CONFLICT1);
	_CASE(STATUS_IP_ADDRESS_CONFLICT2);
	_CASE(STATUS_REGISTRY_QUOTA_LIMIT);
	_CASE(STATUS_PATH_NOT_COVERED);
	_CASE(STATUS_NO_CALLBACK_ACTIVE);
	_CASE(STATUS_LICENSE_QUOTA_EXCEEDED);
	_CASE(STATUS_PWD_TOO_SHORT);
	_CASE(STATUS_PWD_TOO_RECENT);
	_CASE(STATUS_PWD_HISTORY_CONFLICT);
	_CASE(STATUS_PLUGPLAY_NO_DEVICE);
	_CASE(STATUS_UNSUPPORTED_COMPRESSION);
	_CASE(STATUS_INVALID_HW_PROFILE);
	_CASE(STATUS_INVALID_PLUGPLAY_DEVICE_PATH);
	_CASE(STATUS_DRIVER_ORDINAL_NOT_FOUND);
	_CASE(STATUS_DRIVER_ENTRYPOINT_NOT_FOUND);
	_CASE(STATUS_RESOURCE_NOT_OWNED);
	_CASE(STATUS_TOO_MANY_LINKS);
	_CASE(STATUS_QUOTA_LIST_INCONSISTENT);
	_CASE(STATUS_FILE_IS_OFFLINE);
	_CASE(STATUS_EVALUATION_EXPIRATION);
	_CASE(STATUS_ILLEGAL_DLL_RELOCATION);
	_CASE(STATUS_LICENSE_VIOLATION);
	_CASE(STATUS_DLL_INIT_FAILED_LOGOFF);
	_CASE(STATUS_DRIVER_UNABLE_TO_LOAD);
	_CASE(STATUS_DFS_UNAVAILABLE);
	_CASE(STATUS_VOLUME_DISMOUNTED);
	_CASE(STATUS_WX86_INTERNAL_ERROR);
	_CASE(STATUS_WX86_FLOAT_STACK_CHECK);
	_CASE(STATUS_VALIDATE_CONTINUE);
	_CASE(STATUS_NO_MATCH);
	_CASE(STATUS_NO_MORE_MATCHES);
	_CASE(STATUS_NOT_A_REPARSE_POINT);
	_CASE(STATUS_IO_REPARSE_TAG_INVALID);
	_CASE(STATUS_IO_REPARSE_TAG_MISMATCH);
	_CASE(STATUS_IO_REPARSE_DATA_INVALID);
	_CASE(STATUS_IO_REPARSE_TAG_NOT_HANDLED);
	_CASE(STATUS_REPARSE_POINT_NOT_RESOLVED);
	_CASE(STATUS_DIRECTORY_IS_A_REPARSE_POINT);
	_CASE(STATUS_RANGE_LIST_CONFLICT);
	_CASE(STATUS_SOURCE_ELEMENT_EMPTY);
	_CASE(STATUS_DESTINATION_ELEMENT_FULL);
	_CASE(STATUS_ILLEGAL_ELEMENT_ADDRESS);
	_CASE(STATUS_MAGAZINE_NOT_PRESENT);
	_CASE(STATUS_REINITIALIZATION_NEEDED);
	_CASE(STATUS_DEVICE_REQUIRES_CLEANING);
	_CASE(STATUS_DEVICE_DOOR_OPEN);
	_CASE(STATUS_ENCRYPTION_FAILED);
	_CASE(STATUS_DECRYPTION_FAILED);
	_CASE(STATUS_RANGE_NOT_FOUND);
	_CASE(STATUS_NO_RECOVERY_POLICY);
	_CASE(STATUS_NO_EFS);
	_CASE(STATUS_WRONG_EFS);
	_CASE(STATUS_NO_USER_KEYS);
	_CASE(STATUS_FILE_NOT_ENCRYPTED);
	_CASE(STATUS_NOT_EXPORT_FORMAT);
	_CASE(STATUS_FILE_ENCRYPTED);
	_CASE(STATUS_WAKE_SYSTEM);
	_CASE(STATUS_WMI_GUID_NOT_FOUND);
	_CASE(STATUS_WMI_INSTANCE_NOT_FOUND);
	_CASE(STATUS_WMI_ITEMID_NOT_FOUND);
	_CASE(STATUS_WMI_TRY_AGAIN);
	_CASE(STATUS_SHARED_POLICY);
	_CASE(STATUS_POLICY_OBJECT_NOT_FOUND);
	_CASE(STATUS_POLICY_ONLY_IN_DS);
	_CASE(STATUS_VOLUME_NOT_UPGRADED);
	_CASE(STATUS_REMOTE_STORAGE_NOT_ACTIVE);
	_CASE(STATUS_REMOTE_STORAGE_MEDIA_ERROR);
	_CASE(STATUS_NO_TRACKING_SERVICE);
	_CASE(STATUS_SERVER_SID_MISMATCH);
	_CASE(STATUS_DS_NO_ATTRIBUTE_OR_VALUE);
	_CASE(STATUS_DS_INVALID_ATTRIBUTE_SYNTAX);
	_CASE(STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED);
	_CASE(STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS);
	_CASE(STATUS_DS_BUSY);
	_CASE(STATUS_DS_UNAVAILABLE);
	_CASE(STATUS_DS_NO_RIDS_ALLOCATED);
	_CASE(STATUS_DS_NO_MORE_RIDS);
	_CASE(STATUS_DS_INCORRECT_ROLE_OWNER);
	_CASE(STATUS_DS_RIDMGR_INIT_ERROR);
	_CASE(STATUS_DS_OBJ_CLASS_VIOLATION);
	_CASE(STATUS_DS_CANT_ON_NON_LEAF);
	_CASE(STATUS_DS_CANT_ON_RDN);
	_CASE(STATUS_DS_CANT_MOD_OBJ_CLASS);
	_CASE(STATUS_DS_CROSS_DOM_MOVE_FAILED);
	_CASE(STATUS_DS_GC_NOT_AVAILABLE);
	_CASE(STATUS_DIRECTORY_SERVICE_REQUIRED);
	_CASE(STATUS_REPARSE_ATTRIBUTE_CONFLICT);
	_CASE(STATUS_CANT_ENABLE_DENY_ONLY);
	_CASE(STATUS_FLOAT_MULTIPLE_FAULTS);
	_CASE(STATUS_FLOAT_MULTIPLE_TRAPS);
	_CASE(STATUS_DEVICE_REMOVED);
	_CASE(STATUS_JOURNAL_DELETE_IN_PROGRESS);
	_CASE(STATUS_JOURNAL_NOT_ACTIVE);
	_CASE(STATUS_NOINTERFACE);
	_CASE(STATUS_DS_ADMIN_LIMIT_EXCEEDED);
	_CASE(STATUS_DRIVER_FAILED_SLEEP);
	_CASE(STATUS_MUTUAL_AUTHENTICATION_FAILED);
	_CASE(STATUS_CORRUPT_SYSTEM_FILE);
	_CASE(STATUS_DATATYPE_MISALIGNMENT_ERROR);
	_CASE(STATUS_WMI_READ_ONLY);
	_CASE(STATUS_WMI_SET_FAILURE);
	_CASE(STATUS_COMMITMENT_MINIMUM);
	_CASE(STATUS_REG_NAT_CONSUMPTION);
	_CASE(STATUS_TRANSPORT_FULL);
	_CASE(STATUS_DS_SAM_INIT_FAILURE);
	_CASE(STATUS_ONLY_IF_CONNECTED);
	_CASE(STATUS_DS_SENSITIVE_GROUP_VIOLATION);
	_CASE(STATUS_PNP_RESTART_ENUMERATION);
	_CASE(STATUS_JOURNAL_ENTRY_DELETED);
	_CASE(STATUS_DS_CANT_MOD_PRIMARYGROUPID);
	_CASE(STATUS_SYSTEM_IMAGE_BAD_SIGNATURE);
	_CASE(STATUS_PNP_REBOOT_REQUIRED);
	_CASE(STATUS_POWER_STATE_INVALID);
	_CASE(STATUS_DS_INVALID_GROUP_TYPE);
	_CASE(STATUS_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN);
	_CASE(STATUS_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN);
	_CASE(STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER);
	_CASE(STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER);
	_CASE(STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER);
	_CASE(STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER);
	_CASE(STATUS_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER);
	_CASE(STATUS_DS_HAVE_PRIMARY_MEMBERS);
	_CASE(STATUS_WMI_NOT_SUPPORTED);
	_CASE(STATUS_INSUFFICIENT_POWER);
	_CASE(STATUS_SAM_NEED_BOOTKEY_PASSWORD);
	_CASE(STATUS_SAM_NEED_BOOTKEY_FLOPPY);
	_CASE(STATUS_DS_CANT_START);
	_CASE(STATUS_DS_INIT_FAILURE);
	_CASE(STATUS_SAM_INIT_FAILURE);
	_CASE(STATUS_DS_GC_REQUIRED);
	_CASE(STATUS_DS_LOCAL_MEMBER_OF_LOCAL_ONLY);
	_CASE(STATUS_DS_NO_FPO_IN_UNIVERSAL_GROUPS);
	_CASE(STATUS_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED);
	_CASE(STATUS_MULTIPLE_FAULT_VIOLATION);
	_CASE(STATUS_NOT_SUPPORTED_ON_SBS);
	_CASE(STATUS_WOW_ASSERTION);
	_CASE(DBG_NO_STATE_CHANGE);
	_CASE(DBG_APP_NOT_IDLE);
	_CASE(RPC_NT_INVALID_STRING_BINDING);
	_CASE(RPC_NT_WRONG_KIND_OF_BINDING);
	_CASE(RPC_NT_INVALID_BINDING);
	_CASE(RPC_NT_PROTSEQ_NOT_SUPPORTED);
	_CASE(RPC_NT_INVALID_RPC_PROTSEQ);
	_CASE(RPC_NT_INVALID_STRING_UUID);
	_CASE(RPC_NT_INVALID_ENDPOINT_FORMAT);
	_CASE(RPC_NT_INVALID_NET_ADDR);
	_CASE(RPC_NT_NO_ENDPOINT_FOUND);
	_CASE(RPC_NT_INVALID_TIMEOUT);
	_CASE(RPC_NT_OBJECT_NOT_FOUND);
	_CASE(RPC_NT_ALREADY_REGISTERED);
	_CASE(RPC_NT_TYPE_ALREADY_REGISTERED);
	_CASE(RPC_NT_ALREADY_LISTENING);
	_CASE(RPC_NT_NO_PROTSEQS_REGISTERED);
	_CASE(RPC_NT_NOT_LISTENING);
	_CASE(RPC_NT_UNKNOWN_MGR_TYPE);
	_CASE(RPC_NT_UNKNOWN_IF);
	_CASE(RPC_NT_NO_BINDINGS);
	_CASE(RPC_NT_NO_PROTSEQS);
	_CASE(RPC_NT_CANT_CREATE_ENDPOINT);
	_CASE(RPC_NT_OUT_OF_RESOURCES);
	_CASE(RPC_NT_SERVER_UNAVAILABLE);
	_CASE(RPC_NT_SERVER_TOO_BUSY);
	_CASE(RPC_NT_INVALID_NETWORK_OPTIONS);
	_CASE(RPC_NT_NO_CALL_ACTIVE);
	_CASE(RPC_NT_CALL_FAILED);
	_CASE(RPC_NT_CALL_FAILED_DNE);
	_CASE(RPC_NT_PROTOCOL_ERROR);
	_CASE(RPC_NT_UNSUPPORTED_TRANS_SYN);
	_CASE(RPC_NT_UNSUPPORTED_TYPE);
	_CASE(RPC_NT_INVALID_TAG);
	_CASE(RPC_NT_INVALID_BOUND);
	_CASE(RPC_NT_NO_ENTRY_NAME);
	_CASE(RPC_NT_INVALID_NAME_SYNTAX);
	_CASE(RPC_NT_UNSUPPORTED_NAME_SYNTAX);
	_CASE(RPC_NT_UUID_NO_ADDRESS);
	_CASE(RPC_NT_DUPLICATE_ENDPOINT);
	_CASE(RPC_NT_UNKNOWN_AUTHN_TYPE);
	_CASE(RPC_NT_MAX_CALLS_TOO_SMALL);
	_CASE(RPC_NT_STRING_TOO_LONG);
	_CASE(RPC_NT_PROTSEQ_NOT_FOUND);
	_CASE(RPC_NT_PROCNUM_OUT_OF_RANGE);
	_CASE(RPC_NT_BINDING_HAS_NO_AUTH);
	_CASE(RPC_NT_UNKNOWN_AUTHN_SERVICE);
	_CASE(RPC_NT_UNKNOWN_AUTHN_LEVEL);
	_CASE(RPC_NT_INVALID_AUTH_IDENTITY);
	_CASE(RPC_NT_UNKNOWN_AUTHZ_SERVICE);
	_CASE(EPT_NT_INVALID_ENTRY);
	_CASE(EPT_NT_CANT_PERFORM_OP);
	_CASE(EPT_NT_NOT_REGISTERED);
	_CASE(RPC_NT_NOTHING_TO_EXPORT);
	_CASE(RPC_NT_INCOMPLETE_NAME);
	_CASE(RPC_NT_INVALID_VERS_OPTION);
	_CASE(RPC_NT_NO_MORE_MEMBERS);
	_CASE(RPC_NT_NOT_ALL_OBJS_UNEXPORTED);
	_CASE(RPC_NT_INTERFACE_NOT_FOUND);
	_CASE(RPC_NT_ENTRY_ALREADY_EXISTS);
	_CASE(RPC_NT_ENTRY_NOT_FOUND);
	_CASE(RPC_NT_NAME_SERVICE_UNAVAILABLE);
	_CASE(RPC_NT_INVALID_NAF_ID);
	_CASE(RPC_NT_CANNOT_SUPPORT);
	_CASE(RPC_NT_NO_CONTEXT_AVAILABLE);
	_CASE(RPC_NT_INTERNAL_ERROR);
	_CASE(RPC_NT_ZERO_DIVIDE);
	_CASE(RPC_NT_ADDRESS_ERROR);
	_CASE(RPC_NT_FP_DIV_ZERO);
	_CASE(RPC_NT_FP_UNDERFLOW);
	_CASE(RPC_NT_FP_OVERFLOW);
	_CASE(RPC_NT_NO_MORE_ENTRIES);
	_CASE(RPC_NT_SS_CHAR_TRANS_OPEN_FAIL);
	_CASE(RPC_NT_SS_CHAR_TRANS_SHORT_FILE);
	_CASE(RPC_NT_SS_IN_NULL_CONTEXT);
	_CASE(RPC_NT_SS_CONTEXT_MISMATCH);
	_CASE(RPC_NT_SS_CONTEXT_DAMAGED);
	_CASE(RPC_NT_SS_HANDLES_MISMATCH);
	_CASE(RPC_NT_SS_CANNOT_GET_CALL_HANDLE);
	_CASE(RPC_NT_NULL_REF_POINTER);
	_CASE(RPC_NT_ENUM_VALUE_OUT_OF_RANGE);
	_CASE(RPC_NT_BYTE_COUNT_TOO_SMALL);
	_CASE(RPC_NT_BAD_STUB_DATA);
	_CASE(RPC_NT_CALL_IN_PROGRESS);
	_CASE(RPC_NT_NO_MORE_BINDINGS);
	_CASE(RPC_NT_GROUP_MEMBER_NOT_FOUND);
	_CASE(EPT_NT_CANT_CREATE);
	_CASE(RPC_NT_INVALID_OBJECT);
	_CASE(RPC_NT_NO_INTERFACES);
	_CASE(RPC_NT_CALL_CANCELLED);
	_CASE(RPC_NT_BINDING_INCOMPLETE);
	_CASE(RPC_NT_COMM_FAILURE);
	_CASE(RPC_NT_UNSUPPORTED_AUTHN_LEVEL);
	_CASE(RPC_NT_NO_PRINC_NAME);
	_CASE(RPC_NT_NOT_RPC_ERROR);
	_CASE(RPC_NT_UUID_LOCAL_ONLY);
	_CASE(RPC_NT_SEC_PKG_ERROR);
	_CASE(RPC_NT_NOT_CANCELLED);
	_CASE(RPC_NT_INVALID_ES_ACTION);
	_CASE(RPC_NT_WRONG_ES_VERSION);
	_CASE(RPC_NT_WRONG_STUB_VERSION);
	_CASE(RPC_NT_INVALID_PIPE_OBJECT);
	_CASE(RPC_NT_INVALID_PIPE_OPERATION);
	_CASE(RPC_NT_WRONG_PIPE_VERSION);
	_CASE(RPC_NT_PIPE_CLOSED);
	_CASE(RPC_NT_PIPE_DISCIPLINE_ERROR);
	_CASE(RPC_NT_PIPE_EMPTY);
	_CASE(RPC_NT_INVALID_ASYNC_HANDLE);
	_CASE(RPC_NT_INVALID_ASYNC_CALL);
	_CASE(RPC_NT_SEND_INCOMPLETE);
	_CASE(STATUS_ACPI_INVALID_OPCODE);
	_CASE(STATUS_ACPI_STACK_OVERFLOW);
	_CASE(STATUS_ACPI_ASSERT_FAILED);
	_CASE(STATUS_ACPI_INVALID_INDEX);
	_CASE(STATUS_ACPI_INVALID_ARGUMENT);
	_CASE(STATUS_ACPI_FATAL);
	_CASE(STATUS_ACPI_INVALID_SUPERNAME);
	_CASE(STATUS_ACPI_INVALID_ARGTYPE);
	_CASE(STATUS_ACPI_INVALID_OBJTYPE);
	_CASE(STATUS_ACPI_INVALID_TARGETTYPE);
	_CASE(STATUS_ACPI_INCORRECT_ARGUMENT_COUNT);
	_CASE(STATUS_ACPI_ADDRESS_NOT_MAPPED);
	_CASE(STATUS_ACPI_INVALID_EVENTTYPE);
	_CASE(STATUS_ACPI_HANDLER_COLLISION);
	_CASE(STATUS_ACPI_INVALID_DATA);
	_CASE(STATUS_ACPI_INVALID_REGION);
	_CASE(STATUS_ACPI_INVALID_ACCESS_SIZE);
	_CASE(STATUS_ACPI_ACQUIRE_GLOBAL_LOCK);
	_CASE(STATUS_ACPI_ALREADY_INITIALIZED);
	_CASE(STATUS_ACPI_NOT_INITIALIZED);
	_CASE(STATUS_ACPI_INVALID_MUTEX_LEVEL);
	_CASE(STATUS_ACPI_MUTEX_NOT_OWNED);
	_CASE(STATUS_ACPI_MUTEX_NOT_OWNER);
	_CASE(STATUS_ACPI_RS_ACCESS);
	_CASE(STATUS_ACPI_INVALID_TABLE);
	_CASE(STATUS_ACPI_REG_HANDLER_FAILED);
	_CASE(STATUS_ACPI_POWER_REQUEST_FAILED);
	_CASE(STATUS_CTX_WINSTATION_NAME_INVALID);
	_CASE(STATUS_CTX_INVALID_PD);
	_CASE(STATUS_CTX_PD_NOT_FOUND);
	_CASE(STATUS_CTX_CDM_CONNECT);
	_CASE(STATUS_CTX_CDM_DISCONNECT);
	_CASE(STATUS_CTX_CLOSE_PENDING);
	_CASE(STATUS_CTX_NO_OUTBUF);
	_CASE(STATUS_CTX_MODEM_INF_NOT_FOUND);
	_CASE(STATUS_CTX_INVALID_MODEMNAME);
	_CASE(STATUS_CTX_RESPONSE_ERROR);
	_CASE(STATUS_CTX_MODEM_RESPONSE_TIMEOUT);
	_CASE(STATUS_CTX_MODEM_RESPONSE_NO_CARRIER);
	_CASE(STATUS_CTX_MODEM_RESPONSE_NO_DIALTONE);
	_CASE(STATUS_CTX_MODEM_RESPONSE_BUSY);
	_CASE(STATUS_CTX_MODEM_RESPONSE_VOICE);
	_CASE(STATUS_CTX_TD_ERROR);
	_CASE(STATUS_CTX_LICENSE_CLIENT_INVALID);
	_CASE(STATUS_CTX_LICENSE_NOT_AVAILABLE);
	_CASE(STATUS_CTX_LICENSE_EXPIRED);
	_CASE(STATUS_CTX_WINSTATION_NOT_FOUND);
	_CASE(STATUS_CTX_WINSTATION_NAME_COLLISION);
	_CASE(STATUS_CTX_WINSTATION_BUSY);
	_CASE(STATUS_CTX_BAD_VIDEO_MODE);
	_CASE(STATUS_CTX_GRAPHICS_INVALID);
	_CASE(STATUS_CTX_NOT_CONSOLE);
	_CASE(STATUS_CTX_CLIENT_QUERY_TIMEOUT);
	_CASE(STATUS_CTX_CONSOLE_DISCONNECT);
	_CASE(STATUS_CTX_CONSOLE_CONNECT);
	_CASE(STATUS_CTX_SHADOW_DENIED);
	_CASE(STATUS_CTX_WINSTATION_ACCESS_DENIED);
	_CASE(STATUS_CTX_INVALID_WD);
	_CASE(STATUS_CTX_WD_NOT_FOUND);
	_CASE(STATUS_CTX_SHADOW_INVALID);
	_CASE(STATUS_CTX_SHADOW_DISABLED);
	_CASE(STATUS_RDP_PROTOCOL_ERROR);
	_CASE(STATUS_CTX_CLIENT_LICENSE_NOT_SET);
	_CASE(STATUS_CTX_CLIENT_LICENSE_IN_USE);
	_CASE(STATUS_PNP_BAD_MPS_TABLE);
	_CASE(STATUS_PNP_TRANSLATION_FAILED);
	_CASE(STATUS_PNP_IRQ_TRANSLATION_FAILED);
	default:         return "STATUS_UNKNOWN";
    }
}

// PsCreateSystemThread proxy procedure
#pragma warning(push)
#pragma warning(disable: 4731)  // disable ebp modification warning
static unsigned int WINAPI PCSTProxy
(
    IN PVOID Parameter
)
{
    PCSTProxyParam *iPCSTProxyParam = (PCSTProxyParam*)Parameter;

    uint32 StartContext1 = (uint32)iPCSTProxyParam->StartContext1;
    uint32 StartContext2 = (uint32)iPCSTProxyParam->StartContext2;
    uint32 StartRoutine  = (uint32)iPCSTProxyParam->StartRoutine;
    BOOL   StartSuspended = (BOOL)iPCSTProxyParam->StartSuspended;
    HANDLE hStartedEvent = (HANDLE)iPCSTProxyParam->hStartedEvent;

    // Once deleted, unable to directly access iPCSTProxyParam in remainder of function.
    delete iPCSTProxyParam;

	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(StartContext1)
		LOG_FUNC_ARG(StartContext2)
		LOG_FUNC_ARG(StartRoutine)
		LOG_FUNC_END;

    if(StartSuspended == TRUE)
        SuspendThread(GetCurrentThread());

    EmuGenerateFS(CxbxKrnl_TLS, CxbxKrnl_TLSData);

    // call thread notification routine(s)
    if(g_iThreadNotificationCount != 0)
    {
		for(int i = 0; i < 16; i++ )
		{
			XTL::XTHREAD_NOTIFY_PROC pfnNotificationRoutine = (XTL::XTHREAD_NOTIFY_PROC)g_pfnThreadNotification[i];

			// If the routine doesn't exist, don't execute it!
			if(pfnNotificationRoutine == NULL)
				continue;

			DbgPrintf("EmuKrnl (0x%X): Calling pfnNotificationRoutine[%d] (0x%.08X)\n", GetCurrentThreadId(), g_iThreadNotificationCount, pfnNotificationRoutine);

			

			pfnNotificationRoutine(TRUE);

			
		}
    }

    // use the special calling convention
    __try
    {
        SetEvent(hStartedEvent);

        

        __asm
        {
            mov         esi, StartRoutine
            push        StartContext2
            push        StartContext1
            push        offset callComplete
            lea         ebp, [esp-4]
            jmp near    esi
        }
    }
    __except(EmuException(GetExceptionInformation()))
    {
        EmuWarning("Problem with ExceptionFilter!");
    }

callComplete:

        

    // call thread notification routine(s)
    if(g_iThreadNotificationCount != 0)
    {
		for(int i = 0; i < 16; i++ )
		{
			XTL::XTHREAD_NOTIFY_PROC pfnNotificationRoutine = (XTL::XTHREAD_NOTIFY_PROC)g_pfnThreadNotification[i];

			// If the routine doesn't exist, don't execute it!
			if(pfnNotificationRoutine == NULL)
				continue;

			DbgPrintf("EmuKrnl (0x%X): Calling pfnNotificationRoutine[%d] (0x%.08X)\n", GetCurrentThreadId(), g_iThreadNotificationCount, pfnNotificationRoutine);

			

			pfnNotificationRoutine(FALSE);

			
		}
    }

    CxbxKrnlTerminateThread();

    return 0;
}
#pragma warning(pop)


NTSTATUS CxbxObjectAttributesToNT(xboxkrnl::POBJECT_ATTRIBUTES ObjectAttributes, NativeObjectAttributes& nativeObjectAttributes, std::string aFileAPIName = "")
{
	NTSTATUS result = 0;
	std::string OriginalPath;
	std::string RelativePath;
	std::string XboxFullPath;
	std::string NativePath;
	EmuNtSymbolicLinkObject* NtSymbolicLinkObject = NULL;
	result = STATUS_SUCCESS;
	if (ObjectAttributes == NULL)
	{
		// When the pointer is nil, make sure we pass nil to Windows too :
		nativeObjectAttributes.NtObjAttrPtr = NULL;
		return result;
	}

	// ObjectAttributes are given, so make sure the pointer we're going to pass to Windows is assigned :
	nativeObjectAttributes.NtObjAttrPtr = &nativeObjectAttributes.NtObjAttr;
	RelativePath = std::string(ObjectAttributes->ObjectName->Buffer, ObjectAttributes->ObjectName->Length);
	OriginalPath = RelativePath;

	// Always trim '\??\' off :
	if ((RelativePath.length() >= 4) && (RelativePath[0] == '\\') && (RelativePath[1] == '?') && (RelativePath[2] == '?') && (RelativePath[3] == '\\'))
		RelativePath.erase(0, 4);

	// Check if we where called from a File-handling API :
	if (!aFileAPIName.empty())
	{
		NtSymbolicLinkObject = NULL;
		// Check if the path starts with a volume indicator :
		if ((RelativePath.length() >= 2) && (RelativePath[1] == ':'))
		{
			// Look up the symbolic link information using the drive letter :
			NtSymbolicLinkObject = FindNtSymbolicLinkObjectByVolumeLetter(RelativePath[0]);
			RelativePath.erase(0, 2); // Remove 'C:'

									  // If the remaining path starts with a ':', remove it (to prevent errors) :
			if ((RelativePath.length() > 0) && (RelativePath[0] == ':'))
				RelativePath.erase(0, 1);  // xbmp needs this, as it accesses 'e::\'
		}
		else if (RelativePath.compare(0, 1, "$") == 0)
		{
			if (RelativePath.compare(0, 5, "$HOME") == 0) // "xbmp" needs this
			{
				NtSymbolicLinkObject = FindNtSymbolicLinkObjectByRootHandle(g_hCurDir);
				RelativePath.erase(0, 5); // Remove '$HOME'
			}
			else
				CxbxKrnlCleanup(("Unsupported path macro : " + OriginalPath).c_str());
		}
		// Check if the path starts with a relative path indicator :
		else if (RelativePath.compare(0, 1, ".") == 0) // "4x4 Evo 2" needs this
		{
			NtSymbolicLinkObject = FindNtSymbolicLinkObjectByRootHandle(g_hCurDir);
			RelativePath.erase(0, 1); // Remove the '.'
		}
		else
		{
			// The path seems to be a device path, look it up :
			NtSymbolicLinkObject = FindNtSymbolicLinkObjectByDevice(RelativePath);
			// Fixup RelativePath path here
			if ((NtSymbolicLinkObject != NULL))
				RelativePath.erase(0, NtSymbolicLinkObject->XboxFullPath.length()); // Remove '\Device\Harddisk0\Partition2'
		}
	
		if ((NtSymbolicLinkObject != NULL))
		{
			// If the remaining path starts with a '\', remove it (to prevent working in a native root) :
			if ((RelativePath.length() > 0) && (RelativePath[0] == '\\'))
				RelativePath.erase(0, 1);
			XboxFullPath = NtSymbolicLinkObject->XboxFullPath;
			NativePath = NtSymbolicLinkObject->NativePath;
			ObjectAttributes->RootDirectory = NtSymbolicLinkObject->RootDirectoryHandle;
		}
		else
		{
			// No symbolic link - as last resort, check if the path accesses a partition from Harddisk0 :
			if (_strnicmp(RelativePath.c_str(), (DeviceHarddisk0 + "\\partition").c_str() ,(DeviceHarddisk0 + "\\partition").length()) != 0)
			{
				result = STATUS_UNRECOGNIZED_VOLUME; // TODO : Is this the correct error?
				EmuWarning((("Path not available : ") + OriginalPath).c_str());
				return result;
			}

			XboxFullPath = RelativePath;
			// Remove Harddisk0 prefix, in the hope that the remaining path might work :
			RelativePath.erase(0, DeviceHarddisk0.length() + 1);
			// And set Root to the folder containing the partition-folders :
			ObjectAttributes->RootDirectory = CxbxBasePathHandle;
			NativePath = CxbxBasePath;
		}

		DbgPrintf("EmuKrnl : %s Corrected path...\n", aFileAPIName.c_str());
		DbgPrintf("  Org:\"%s\"\n", OriginalPath.c_str());
		if (_strnicmp(NativePath.c_str(), CxbxBasePath.c_str(), CxbxBasePath.length()) == 0)
		{
			DbgPrintf("  New:\"$CxbxPath\\EmuDisk\\%s%s\"\n", (NativePath.substr(CxbxBasePath.length(), std::string::npos)).c_str(), RelativePath.c_str());	
		}
		else
			DbgPrintf("  New:\"$XbePath\\%s\"\n", RelativePath.c_str());

	}
	else
	{
		// For non-file API calls, prefix with '\??\' again :
		RelativePath = "\\??\\" + RelativePath;
		ObjectAttributes->RootDirectory = 0;
	}

	// Convert Ansi to Unicode :
	mbstowcs(nativeObjectAttributes.wszObjectName, RelativePath.c_str(), 160);
	NtDll::RtlInitUnicodeString(&nativeObjectAttributes.NtUnicodeString, nativeObjectAttributes.wszObjectName);

	// Initialize the NT ObjectAttributes :
	InitializeObjectAttributes(&nativeObjectAttributes.NtObjAttr, &nativeObjectAttributes.NtUnicodeString, ObjectAttributes->Attributes, ObjectAttributes->RootDirectory, NULL);

	return result;
}


using namespace xboxkrnl;

// ******************************************************************
// * 0x0001 AvGetSavedDataAddress()
// ******************************************************************
XBSYSAPI EXPORTNUM(1) xboxkrnl::PVOID NTAPI xboxkrnl::AvGetSavedDataAddress()
{
	LOG_FUNC();

	__asm int 3;

	// Allocate a buffer the size of the screen buffer and return that.
	// TODO: Fill this buffer with the contents of the front buffer.
	// TODO: This isn't always the size we need...

	if( g_pPersistedData )
	{
		CxbxFree( g_pPersistedData );
		g_pPersistedData = NULL;
	}

	g_pPersistedData = CxbxMalloc( 640*480*4 );

#if 0
	// Get a copy of the front buffer
	IDirect3DSurface8* pFrontBuffer = NULL;

	if( SUCCEEDED(g_pD3DDevice8->GetFrontBuffer(pFrontBuffer)))
	{
		D3DLOCKED_RECT LockedRect;
		pFrontBuffer->LockRect( 0, NULL, &LockedRect );

		CopyMemory( g_pPersistedData, LockRect.pBits, 640*480*4 );

		pFrontBuffer->UnlockRect();
	}
#endif

	// TODO: We might want to return something sometime...
	/*if( !g_pPersistedData )
	{
		FILE* fp = fopen( "PersistedSurface.bin", "rb" );
		fseek( fp, 0, SEEK_END );
		long size = ftell( fp );
		g_pPersistedData = malloc( size );
		fread( g_pPersistedData, size, 1, fp );
		fclose(fp);
	}*/

	return NULL;//g_pPersistedData;
}

// ******************************************************************
// * 0x0002 AvSendTVEncoderOption()
// ******************************************************************
XBSYSAPI EXPORTNUM(2) VOID NTAPI xboxkrnl::AvSendTVEncoderOption
(
    IN  PVOID   RegisterBase,
    IN  ULONG   Option,
    IN  ULONG   Param,
    OUT ULONG   *Result
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(RegisterBase)
		LOG_FUNC_ARG(Option)
		LOG_FUNC_ARG(Param)
		LOG_FUNC_ARG_OUT(Result)
		LOG_FUNC_END;

	// TODO: What does this do?

	EmuWarning( "AvSendTVEncoderOption ignored!" );
}

// ******************************************************************
// * 0x0008 DbgPrint
// ******************************************************************
XBSYSAPI EXPORTNUM(8) xboxkrnl::ULONG _cdecl xboxkrnl::DbgPrint
(
	PCHAR  Format, ...
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(Format)
		LOG_FUNC_ARG("...")
		LOG_FUNC_END;

	if(Format != NULL) 
	{
		char szBuffer[MAX_PATH];

		va_list argp;
		va_start(argp, Format);

		vsprintf(szBuffer, Format, argp);
		va_end(argp);

		//LogPrintf("[EmuKrnl] DbgPrint: %s", szBuffer);

		EmuWarning(szBuffer);
		//DbgPrintf(szBuffer);
	}

	return STATUS_SUCCESS;
}

// ******************************************************************
// * 0x0009 HalReadSMCTrayState
// ******************************************************************
XBSYSAPI EXPORTNUM(9) VOID NTAPI xboxkrnl::HalReadSMCTrayState
(
	DWORD*	State,
	DWORD*	Count
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(State)
		LOG_FUNC_ARG(Count)
		LOG_FUNC_END;

#define TRAY_CLOSED_MEDIA_PRESENT 96
#define TRAY_CLOSED_NO_MEDIA 64
#define TRAY_OPEN 16

	// TODO: Make this configurable?
	// TODO: What is the count parameter for??

	// Pretend the tray is open
	// TRAY_CLOSED_NO_MEDIA causes Dashboard to call DeviceIoControl, which we do not implement
	// TRAY_CLOSED_MEDIA_PRESENT causes Dashboard to attempt to launch media, causing errors.
	*State = TRAY_OPEN;
//	*Count = 1;

		
}

// ******************************************************************
// * 0x000E ExAllocatePool
// ******************************************************************
XBSYSAPI EXPORTNUM(14) xboxkrnl::PVOID NTAPI xboxkrnl::ExAllocatePool
(
    IN ULONG NumberOfBytes
)
{
	LOG_FUNC_ONE_ARG(NumberOfBytes);

    PVOID pRet = ExAllocatePoolWithTag(NumberOfBytes, (ULONG)"enoN");

	return pRet;
}

// ******************************************************************
// * 0x000F ExAllocatePoolWithTag
// ******************************************************************
// * Differences from NT: There is no PoolType field, as the XBOX
// * only has 1 pool, the non-paged pool.
// ******************************************************************
XBSYSAPI EXPORTNUM(15) xboxkrnl::PVOID NTAPI xboxkrnl::ExAllocatePoolWithTag
(
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(NumberOfBytes)
		LOG_FUNC_ARG(Tag)
		LOG_FUNC_END;

    // TODO: Actually implement this
    PVOID pRet = CxbxMalloc(NumberOfBytes);

	return pRet;
}

// ******************************************************************
// * 0x0011 ExFreePool
// ******************************************************************
XBSYSAPI EXPORTNUM(17) VOID NTAPI xboxkrnl::ExFreePool
(
	IN PVOID	P
)
{
	LOG_FUNC_ONE_ARG(P);

	CxbxFree(P);
}

// ******************************************************************
// * 0x0017 ExQueryPoolBlockSize
// ******************************************************************
XBSYSAPI EXPORTNUM(23) xboxkrnl::ULONG NTAPI xboxkrnl::ExQueryPoolBlockSize
(
	IN PVOID PoolBlock
)
{
	LOG_FUNC_ONE_ARG(PoolBlock);

	// Not strictly correct, but it will do for now
	return MmQueryAllocationSize(PoolBlock);
}

// ******************************************************************
// * 0x0018 ExQueryNonVolatileSetting
// ******************************************************************
XBSYSAPI EXPORTNUM(24) xboxkrnl::NTSTATUS NTAPI xboxkrnl::ExQueryNonVolatileSetting
(
    IN  EEPROM_INDEX        ValueIndex,
    OUT DWORD              *Type,
    OUT PUCHAR              Value,
    IN  SIZE_T              ValueLength,
    OUT PSIZE_T             ResultLength OPTIONAL
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(ValueIndex)
		LOG_FUNC_ARG_OUT(Type)
		LOG_FUNC_ARG_OUT(Value)
		LOG_FUNC_ARG(ValueLength)
		LOG_FUNC_ARG_OUT(ResultLength)
		LOG_FUNC_END;

    if (!Type || !Value)
        CxbxKrnlCleanup("Assertion in ExQueryNonVolatileSetting()");

    NTSTATUS ret = STATUS_SUCCESS;

    // handle eeprom read
    switch(ValueIndex)
    {
        // Factory Game Region
        case EEPROM_FACTORY_GAME_REGION:
        {
            // TODO: configurable region or autodetect of some sort
            if(ResultLength != 0)
                *ResultLength = 0x04;

            if(ValueLength >= 4) {
                *Type = 0x04;
                *Value = 0x01;  // North America
            }
        }
        break;

        // Factory AV Region
		case EEPROM_FACTORY_AV_REGION:
        {
            // TODO: configurable region or autodetect of some sort
            if(ResultLength != 0)
                *ResultLength = 0x04;
			
            *Type = 0x04;
            *Value = 0x01; // NTSC_M
        }
        break;

        // Language
		case EEPROM_LANGUAGE:
        {
            // TODO: configurable language or autodetect of some sort
            if(ResultLength != 0)
                *ResultLength = 0x04;

            *Type = 0x04;
            *Value = 0x01;  // English
        }
        break;

        // Video Flag
		case EEPROM_VIDEO:
        {
            // TODO: configurable video flags or autodetect of some sort
            if(ResultLength != 0)
                *ResultLength = 0x04;

            *Type = 0x04;
            *Value = 0x10;  // Letterbox
        }
        break;

        // Audio Flags
		case EEPROM_AUDIO:
        {
            if(ResultLength != 0)
                *ResultLength = 0x04;            
            
            *Type = 0x04;
            *Value = 0;  // Stereo, no AC3, no DTS
        }
        break;

		case EEPROM_MISC:
        {
            if(ResultLength != 0)
                *ResultLength = 0x04;
            
            *Type  = 0x04;
            *Value = 0;  // No automatic power down
        }
        break;

		case EEPROM_MAX_OS:
        {
            // This is called to return a complete XBOX_USER_SETTINGS structure
            //
            // One example is from XapipQueryTimeZoneInformation(), where it is used to
            // detect the local timezone information.

            // TODO
        }
        break;

        default:
            EmuWarning("ExQueryNonVolatileSetting unknown ValueIndex (%d)", ValueIndex);
            ret = STATUS_OBJECT_NAME_NOT_FOUND;
            break;
    }

    

    return ret;
}

// ******************************************************************
// * 0x0019 - ExReadWriteRefurbInfo
// ******************************************************************
XBSYSAPI EXPORTNUM(25) xboxkrnl::NTSTATUS NTAPI xboxkrnl::ExReadWriteRefurbInfo
(
	PVOID	Unknown1,
	DWORD	Unknown2,
	DWORD	Unknown3
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(Unknown1)
		LOG_FUNC_ARG(Unknown2)
		LOG_FUNC_ARG(Unknown3)
		LOG_FUNC_END;

	// TODO: What does this do?
	EmuWarning( "ExReadWriteRefurbInfo ignored!" );

	return STATUS_SUCCESS;
}

// ******************************************************************
// * 0x001D - ExSaveNonVolatileSetting
// ******************************************************************
XBSYSAPI EXPORTNUM(29) xboxkrnl::NTSTATUS NTAPI xboxkrnl::ExSaveNonVolatileSetting
(
    IN  DWORD               ValueIndex,
    OUT DWORD              *Type,
    IN  PUCHAR              Value,
    IN  SIZE_T              ValueLength
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(ValueIndex)
		LOG_FUNC_ARG_OUT(Type)
		LOG_FUNC_ARG(Value)
		LOG_FUNC_ARG(ValueLength)
		LOG_FUNC_END;

	// TODO: Later.

	return STATUS_SUCCESS;
}

// ******************************************************************
// * 0x0023 - FscGetCacheSize
// ******************************************************************
XBSYSAPI EXPORTNUM(35) xboxkrnl::DWORD NTAPI xboxkrnl::FscGetCacheSize()
{
	LOG_FUNC();

    EmuWarning("FscGetCacheSize returning default 64kb");

	return 64*1024;
}

// ******************************************************************
// * 0x0025 - FscSetCacheSize
// ******************************************************************
XBSYSAPI EXPORTNUM(37) xboxkrnl::LONG NTAPI xboxkrnl::FscSetCacheSize
(
	ULONG uCachePages
)
{
	LOG_FUNC_ONE_ARG(uCachePages);

    EmuWarning("FscSetCacheSize is being ignored");

    return 0;
}

// ******************************************************************
// * HalGetInterruptVector
// ******************************************************************
XBSYSAPI EXPORTNUM(44) xboxkrnl::ULONG  NTAPI xboxkrnl::HalGetInterruptVector
(
    IN ULONG   InterruptLevel,
    OUT CHAR*  Irql
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(InterruptLevel)
		LOG_FUNC_ARG_OUT(Irql)
		LOG_FUNC_END;

	// I'm only adding this for Virtua Cop 3 (Chihiro). Xbox games need not emulate this.

	EmuWarning( "HalGetInterruptVector(): If this is NOT a Chihiro game, tell blueshogun!" );

	return 1;
}

// ******************************************************************
// * 0x002D - HalReadSMBusValue
// ******************************************************************
XBSYSAPI EXPORTNUM(45) xboxkrnl::NTSTATUS NTAPI xboxkrnl::HalReadSMBusValue
(
    IN  UCHAR               Address,
    IN  UCHAR               Command,
    IN  BOOLEAN             ReadWord,
    OUT PULONG              DataValue
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(Address)
		LOG_FUNC_ARG(Command)
		LOG_FUNC_ARG(ReadWord)
		LOG_FUNC_ARG_OUT(DataValue)
		LOG_FUNC_END;

    if (ReadWord) {
        // Write UCHAR
    } else {
        // Write BYTE
    }


	return STATUS_SUCCESS;
}

// ******************************************************************
// * 0x002F - HalRegisterShutdownNotification
// ******************************************************************
XBSYSAPI EXPORTNUM(47) VOID xboxkrnl::HalRegisterShutdownNotification
(
	IN PHAL_SHUTDOWN_REGISTRATION ShutdownRegistration,
	IN BOOLEAN Register
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(ShutdownRegistration)
		LOG_FUNC_ARG(Register)
		LOG_FUNC_END;

	EmuWarning("HalRegisterShutdownNotification not implemented!\n");

	return;
}


// ******************************************************************
// * 0x0031 - HalReturnToFirmware
// ******************************************************************
XBSYSAPI EXPORTNUM(49) VOID DECLSPEC_NORETURN xboxkrnl::HalReturnToFirmware
(
    RETURN_FIRMWARE Routine
)
{
	LOG_FUNC_ONE_ARG(Routine);

	// Prevent the dashboard from rebooting due to unimplemented crypto routines
	if ((uint32_t)Routine != 4) {
		CxbxKrnlCleanup("Xbe has rebooted : HalReturnToFirmware(%d)", Routine);
	}
}

// ******************************************************************
// * 0x0032 - HalWriteSMBusValue
// ******************************************************************
XBSYSAPI EXPORTNUM(50) xboxkrnl::NTSTATUS NTAPI xboxkrnl::HalWriteSMBusValue
(
    IN  UCHAR               Address,
    IN  UCHAR               Command,
    IN  BOOLEAN             WriteWord,
    IN  ULONG               DataValue
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(Address)
		LOG_FUNC_ARG(Command)
		LOG_FUNC_ARG(WriteWord)
		LOG_FUNC_ARG(DataValue)
		LOG_FUNC_END;

	// TODO: Later.

	return STATUS_SUCCESS;
}

// ******************************************************************
// * 0x0042 - IoCreateFile
// ******************************************************************
XBSYSAPI EXPORTNUM(66) xboxkrnl::NTSTATUS NTAPI xboxkrnl::IoCreateFile
(
    OUT PHANDLE             FileHandle,
    IN  ACCESS_MASK         DesiredAccess,
    IN  POBJECT_ATTRIBUTES  ObjectAttributes,
    OUT PIO_STATUS_BLOCK    IoStatusBlock,
    IN  PLARGE_INTEGER      AllocationSize,
    IN  ULONG               FileAttributes,
    IN  ULONG               ShareAccess,
    IN  ULONG               Disposition,
    IN  ULONG               CreateOptions,
    IN  ULONG               Options
)
{
	LOG_FUNC_BEGIN 
		LOG_FUNC_ARG_OUT(FileHandle)
		LOG_FUNC_ARG(DesiredAccess)
		LOG_FUNC_ARG(ObjectAttributes)
		LOG_FUNC_ARG_OUT(IoStatusBlock)
		LOG_FUNC_ARG(AllocationSize)
		LOG_FUNC_ARG(FileAttributes)
		LOG_FUNC_ARG(ShareAccess)
		LOG_FUNC_ARG(Disposition)
		LOG_FUNC_ARG(CreateOptions)
		LOG_FUNC_ARG(Options)
		LOG_FUNC_END;

    NTSTATUS ret = STATUS_SUCCESS;

    // TODO: Try redirecting to NtCreateFile if this function ever is run into
    CxbxKrnlCleanup("IoCreateFile not implemented");

    

    return ret;
}

// ******************************************************************
// * 0x0043 IoCreateSymbolicLink
// ******************************************************************
XBSYSAPI EXPORTNUM(67) xboxkrnl::NTSTATUS NTAPI xboxkrnl::IoCreateSymbolicLink
(
    IN PSTRING SymbolicLinkName,
    IN PSTRING DeviceName
)
{
	LOG_FUNC_BEGIN 
		LOG_FUNC_ARG(SymbolicLinkName)
		LOG_FUNC_ARG(DeviceName)
		LOG_FUNC_END;

	NTSTATUS ret = CxbxCreateSymbolicLink(std::string(SymbolicLinkName->Buffer, SymbolicLinkName->Length), std::string(DeviceName->Buffer, DeviceName->Length));

	return ret;
}

// ******************************************************************
// * 0x0045 - IoDeleteSymbolicLink
// ******************************************************************
XBSYSAPI EXPORTNUM(69) xboxkrnl::NTSTATUS NTAPI xboxkrnl::IoDeleteSymbolicLink
(
    IN PSTRING SymbolicLinkName
)
{
	LOG_FUNC_ONE_ARG(SymbolicLinkName);

	EmuNtSymbolicLinkObject* symbolicLink = FindNtSymbolicLinkObjectByName(std::string(SymbolicLinkName->Buffer, SymbolicLinkName->Length));
    
	NTSTATUS ret = STATUS_OBJECT_NAME_NOT_FOUND;

	if ((symbolicLink != NULL))
		ret = symbolicLink->NtClose();

	return ret;
}

// ******************************************************************
// * IoDismountVolumeByName
// ******************************************************************
XBSYSAPI EXPORTNUM(91) xboxkrnl::NTSTATUS NTAPI xboxkrnl::IoDismountVolumeByName
(
	IN PSTRING VolumeName
)
{
	LOG_FUNC_ONE_ARG(VolumeName);

	// TODO: Anything?
	NTSTATUS ret = STATUS_SUCCESS;

	return ret;
}

// ******************************************************************
// * KeBugCheck
// ******************************************************************
XBSYSAPI EXPORTNUM(95) VOID NTAPI xboxkrnl::KeBugCheck
(
	IN ULONG BugCheckMode
)
{
	LOG_FUNC_ONE_ARG(BugCheckMode);

	// TODO: Investigate XapiFiberStartup maybe?
}

// ******************************************************************
// * KeConnectInterrupt
// ******************************************************************
XBSYSAPI EXPORTNUM(98) xboxkrnl::LONG NTAPI xboxkrnl::KeConnectInterrupt
(
    IN PKINTERRUPT  InterruptObject
)
{
	LOG_FUNC_ONE_ARG(InterruptObject);

	return 0;
}

// ******************************************************************
// * 0x0063 - KeDelayExecutionThread
// ******************************************************************
XBSYSAPI EXPORTNUM(99) xboxkrnl::NTSTATUS NTAPI xboxkrnl::KeDelayExecutionThread
(
    IN KPROCESSOR_MODE  WaitMode,
    IN BOOLEAN          Alertable,
    IN PLARGE_INTEGER   Interval
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(WaitMode)
		LOG_FUNC_ARG(Alertable)
		LOG_FUNC_ARG(Interval)
		LOG_FUNC_END;

    NTSTATUS ret = NtDll::NtDelayExecution(Alertable, (NtDll::LARGE_INTEGER*)Interval);

	return ret;
}

// ******************************************************************
// * 0x006B - KeInitializeDpc
// ******************************************************************
XBSYSAPI EXPORTNUM(107) VOID NTAPI xboxkrnl::KeInitializeDpc
(
    KDPC                *Dpc,
    PKDEFERRED_ROUTINE   DeferredRoutine,
    PVOID                DeferredContext
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(Dpc)
		LOG_FUNC_ARG(DeferredRoutine)
		LOG_FUNC_ARG(DeferredContext)
		LOG_FUNC_END;

    // inialize Dpc field values
    Dpc->DeferredRoutine = DeferredRoutine;
    Dpc->Type = DpcObject;
    Dpc->DeferredContext = DeferredContext;
    Dpc->Inserted = FALSE;

    return;
}

// ******************************************************************
// * 0x006D - KeInitializeInterrupt
// ******************************************************************
XBSYSAPI EXPORTNUM(109) VOID NTAPI xboxkrnl::KeInitializeInterrupt
(
    OUT PKINTERRUPT Interrupt,
    IN PKSERVICE_ROUTINE ServiceRoutine,
    IN PVOID ServiceContext,
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KINTERRUPT_MODE InterruptMode,
    IN BOOLEAN ShareVector
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG_OUT(Interrupt)
		LOG_FUNC_ARG(ServiceRoutine)
		LOG_FUNC_ARG(ServiceContext)
		LOG_FUNC_ARG(Vector)
		LOG_FUNC_ARG(Irql)
		LOG_FUNC_ARG(InterruptMode)
		LOG_FUNC_ARG(ShareVector)
		LOG_FUNC_END;

}

// ******************************************************************
// * 0x0071 - KeInitializeTimerEx
// ******************************************************************
XBSYSAPI EXPORTNUM(113) VOID NTAPI xboxkrnl::KeInitializeTimerEx
(
    IN PKTIMER      Timer,
    IN TIMER_TYPE   Type
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(Timer)
		LOG_FUNC_ARG(Type)
		LOG_FUNC_END;

    Timer->Header.Type               = Type + 8;  // 8 = TimerNotificationObject 
    Timer->Header.Inserted           = 0;
    Timer->Header.Size               = sizeof(KTIMER) / sizeof(ULONG);
    Timer->Header.SignalState        = 0;

    Timer->TimerListEntry.Blink      = NULL;
    Timer->TimerListEntry.Flink      = NULL;
    Timer->Header.WaitListHead.Flink = &Timer->Header.WaitListHead;
    Timer->Header.WaitListHead.Blink = &Timer->Header.WaitListHead;

    Timer->DueTime.QuadPart          = 0;
    Timer->Period                    = 0;

    

    return;
}

// ******************************************************************
// * KeQueryPerformanceCounter
// ******************************************************************
XBSYSAPI EXPORTNUM(126) xboxkrnl::ULONGLONG NTAPI xboxkrnl::KeQueryPerformanceCounter()
{
    LOG_FUNC();

    ::LARGE_INTEGER Counter;

    QueryPerformanceCounter(&Counter);

	return Counter.QuadPart;
}

// ******************************************************************
// * KeQueryPerformanceFrequency
// ******************************************************************
XBSYSAPI EXPORTNUM(127) xboxkrnl::ULONGLONG NTAPI xboxkrnl::KeQueryPerformanceFrequency()
{
    LOG_FUNC();

    // Xbox Performance Counter Frequency := 337F98h
    ::LARGE_INTEGER Frequency;

    QueryPerformanceFrequency(&Frequency);

	return Frequency.QuadPart;
}

// ******************************************************************
// * 0x0080 - KeQuerySystemTime
// ******************************************************************
XBSYSAPI EXPORTNUM(128) VOID NTAPI xboxkrnl::KeQuerySystemTime
(
    PLARGE_INTEGER CurrentTime
)
{
	LOG_FUNC_ONE_ARG(CurrentTime);

    // TODO: optimize for WinXP if speed ever becomes important here

    SYSTEMTIME SystemTime;

    GetSystemTime(&SystemTime);

    SystemTimeToFileTime(&SystemTime, (FILETIME*)CurrentTime);

    return;
}

// ******************************************************************
// * KeRaiseIrqlToDpcLevel
// ******************************************************************
XBSYSAPI EXPORTNUM(129) xboxkrnl::UCHAR NTAPI xboxkrnl::KeRaiseIrqlToDpcLevel()
{
    LOG_FUNC();

	// I really tried to avoid adding this...
//	__asm int 3;
//	CxbxKrnlCleanup("KeRaiseIrqlToDpcLevel not implemented! (Tell blueshogun -_-)");

	return 0;
}

// ******************************************************************
// * 0x0095 - KeSetTimer
// ******************************************************************
XBSYSAPI EXPORTNUM(149) xboxkrnl::BOOLEAN NTAPI xboxkrnl::KeSetTimer
(
    IN PKTIMER        Timer,
    IN LARGE_INTEGER  DueTime,
    IN PKDPC          Dpc OPTIONAL
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(Timer)
		LOG_FUNC_ARG(DueTime)
		LOG_FUNC_ARG(Dpc)
		LOG_FUNC_END;

    // Call KeSetTimerEx with a period of zero
    BOOLEAN bRet = KeSetTimerEx(Timer, DueTime, 0, Dpc);

	return bRet;
}

// ******************************************************************
// * 0x0096 - KeSetTimerEx
// ******************************************************************
XBSYSAPI EXPORTNUM(150) xboxkrnl::BOOLEAN NTAPI xboxkrnl::KeSetTimerEx
(
    IN PKTIMER        Timer,
    IN LARGE_INTEGER  DueTime,
    IN LONG           Period OPTIONAL,
    IN PKDPC          Dpc OPTIONAL
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(Timer)
		LOG_FUNC_ARG(DueTime)
		LOG_FUNC_ARG(Period)
		LOG_FUNC_ARG(Dpc)
		LOG_FUNC_END;

    BOOLEAN Inserted;
    LARGE_INTEGER Interval;
    LARGE_INTEGER SystemTime;

    #define RemoveEntryList(e) do { PLIST_ENTRY f = (e)->Flink, b = (e)->Blink; f->Blink = b; b->Flink = f; (e)->Flink = (e)->Blink = NULL; } while (0)

    if (Timer->Header.Type != 8 && Timer->Header.Type != 9) {
        CxbxKrnlCleanup("Assertion: '(Timer)->Header.Type == TimerNotificationObject) || ((Timer)->Header.Type == TimerSynchronizationObject)' in KeSetTimerEx()");
    }

    Inserted = Timer->Header.Inserted;
    if (Inserted != FALSE) {
        // Do some unlinking if already inserted in the linked list
        Timer->Header.Inserted = FALSE;
        RemoveEntryList(&Timer->TimerListEntry);
    }

    Timer->Header.SignalState = FALSE;
    Timer->Dpc = Dpc;
    Timer->Period = Period;

    if (/*!KiInsertTreeTimer(Timer,DueTime)*/ TRUE) {
        if (Timer->Header.WaitListHead.Flink != &Timer->Header.WaitListHead) {
            // KiWaitTest(Timer, 0);
        }

        if (Dpc != NULL) {
            // Call the Dpc routine if one is specified
            KeQuerySystemTime(&SystemTime);
            // Need to implement KeInsertQueueDpc xboxkrnl.exe export (ordinal 119)
            // KeInsertQueueDpc(Timer->Dpc, SystemTime.LowPart, SystemTime.HighPart);
        }

        if (Period != 0) {
            // Prepare the repetition if Timer is periodic
            Interval.QuadPart = (-10 * 1000) * Timer->Period;
            while (/*!KiInsertTreeTimer(Timer,Interval)*/TRUE) {
                ;
            }
        }
    }

	return Inserted;
}

// ******************************************************************
// * 0x009C - KeTickCount
// ******************************************************************
XBSYSAPI EXPORTNUM(156) volatile xboxkrnl::DWORD xboxkrnl::KeTickCount = 0;

// ******************************************************************
// * xLaunchDataPage (pointed to by LaunchDataPage)
// ******************************************************************
LAUNCH_DATA_PAGE xLaunchDataPage =
{
    {   // header
        2,  // 2: dashboard, 0: title
        0,
        "D:\\default.xbe",
        0
    }
};

// TODO: Verify this is the correct amount
xboxkrnl::ULONG xboxkrnl::HalDiskCachePartitionCount = 3;

// ******************************************************************
// * 0x009E - KeWaitForMultipleObjects
// ******************************************************************
XBSYSAPI EXPORTNUM(158) xboxkrnl::NTSTATUS xboxkrnl::KeWaitForMultipleObjects
(
	IN ULONG Count,
	IN PVOID Object[],
	IN WAIT_TYPE WaitType,
	IN int WaitReason,
	IN KPROCESSOR_MODE WaitMode,
	IN BOOLEAN Alertable,
	IN PLARGE_INTEGER Timeout OPTIONAL,
	IN VOID* WaitBlockArray
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(Count)
		LOG_FUNC_ARG(Object)
		LOG_FUNC_ARG(WaitType)
		LOG_FUNC_ARG(WaitReason)
		LOG_FUNC_ARG(WaitMode)
		LOG_FUNC_ARG(Alertable)
		LOG_FUNC_ARG(Timeout)
		LOG_FUNC_ARG(WaitBlockArray)
		LOG_FUNC_END;

	EmuWarning("EmuKrnl: Redirecting KeWaitForMultipleObjects to NtWaitForMultipleObjectsEx");

	return NtWaitForMultipleObjectsEx(Count, Object, WaitType, WaitMode, Alertable, Timeout);
}

// ******************************************************************
// * 0x009F - KeWaitForSingleObject
// ******************************************************************
XBSYSAPI EXPORTNUM(159) xboxkrnl::NTSTATUS xboxkrnl::KeWaitForSingleObject
(
	IN PVOID Object,
	IN int WaitReason,
	IN KPROCESSOR_MODE WaitMode,
	IN BOOLEAN Alertable,
	IN PLARGE_INTEGER Timeout OPTIONAL
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(Object)
		LOG_FUNC_ARG(WaitReason)
		LOG_FUNC_ARG(WaitMode)
		LOG_FUNC_ARG(Alertable)
		LOG_FUNC_ARG(Timeout)
		LOG_FUNC_END;

	EmuWarning("EmuKrnl: Redirecting KeWaitForSingleObject to NtWaitForSingleObjectEx");

	return NtWaitForSingleObjectEx(Object, WaitMode, Alertable, Timeout);
}

// ******************************************************************
// * 0x00A0 - KfRaiseIrql
// ******************************************************************
XBSYSAPI EXPORTNUM(160) xboxkrnl::UCHAR* NTAPI xboxkrnl::KfRaiseIrql
(
    IN UCHAR NewIrql
)
{
	// HACK: Not thread safe!
	static xboxkrnl::UCHAR previousIrqlValue = 0;

	LOG_FUNC_ONE_ARG(NewIrql);
    
	// Return addr where old irq level should be stored
    return &previousIrqlValue;
}

// ******************************************************************
// * 0x00A1 - KfLowerIrql
// ******************************************************************
XBSYSAPI EXPORTNUM(161) VOID NTAPI xboxkrnl::KfLowerIrql
(
    IN UCHAR NewIrql
)
{
	LOG_FUNC_ONE_ARG(NewIrql);

}

// ******************************************************************
// * 0x00A4 - LaunchDataPage (actually a pointer)
// ******************************************************************
XBSYSAPI EXPORTNUM(164) xboxkrnl::PLAUNCH_DATA_PAGE xboxkrnl::LaunchDataPage = &xLaunchDataPage;

// ******************************************************************
// * 0x00A5 - MmAllocateContiguousMemory
// ******************************************************************
XBSYSAPI EXPORTNUM(165) xboxkrnl::PVOID NTAPI xboxkrnl::MmAllocateContiguousMemory
(
    IN ULONG NumberOfBytes
)
{
	LOG_FUNC_ONE_ARG(NumberOfBytes);

    //
    // NOTE: Kludgey (but necessary) solution:
    //
    // Since this memory must be aligned on a page boundary, we must allocate an extra page
    // so that we can return a valid page aligned pointer
    //

    PVOID pRet = CxbxMalloc(NumberOfBytes + 0x1000);

    // align to page boundary
    {
        DWORD dwRet = (DWORD)pRet;

        dwRet += 0x1000 - dwRet%0x1000;

        g_AlignCache.insert(dwRet, pRet);

        pRet = (PVOID)dwRet;
    }

    DbgPrintf("EmuKrnl (0x%X): MmAllocateContiguousMemory returned 0x%.08X\n", GetCurrentThreadId(), pRet);

	return pRet;
}

// ******************************************************************
// * 0x00A6 - MmAllocateContiguousMemoryEx
// ******************************************************************
XBSYSAPI EXPORTNUM(166) xboxkrnl::PVOID NTAPI xboxkrnl::MmAllocateContiguousMemoryEx
(
    IN ULONG            NumberOfBytes,
    IN PHYSICAL_ADDRESS LowestAcceptableAddress,
    IN PHYSICAL_ADDRESS HighestAcceptableAddress,
    IN ULONG            Alignment OPTIONAL,
    IN ULONG            ProtectionType
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(NumberOfBytes)
		LOG_FUNC_ARG(LowestAcceptableAddress)
		LOG_FUNC_ARG(HighestAcceptableAddress)
		LOG_FUNC_ARG(Alignment)
		LOG_FUNC_ARG(ProtectionType)
		LOG_FUNC_END;

    //
    // NOTE: Kludgey (but necessary) solution:
    //
    // Since this memory must be aligned on a page boundary, we must allocate an extra page
    // so that we can return a valid page aligned pointer
    //

    PVOID pRet = CxbxMalloc(NumberOfBytes + 0x1000);

    // align to page boundary
    {
        DWORD dwRet = (DWORD)pRet;

        dwRet += 0x1000 - dwRet%0x1000;

        g_AlignCache.insert(dwRet, pRet);

        pRet = (PVOID)dwRet;
    }

    static int count = 0;

    DbgPrintf("EmuKrnl (0x%X): MmAllocateContiguousMemoryEx returned 0x%.08X\n", GetCurrentThreadId(), pRet);

	return pRet;
}

// ******************************************************************
// * 0x00A7 - MmAllocateSystemMemory
// ******************************************************************
XBSYSAPI EXPORTNUM(167) xboxkrnl::PVOID NTAPI xboxkrnl::MmAllocateSystemMemory
(
    ULONG NumberOfBytes,
    ULONG Protect
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(NumberOfBytes)
		LOG_FUNC_ARG(Protect)
		LOG_FUNC_END;

    // TODO: should this be aligned?
    PVOID pRet = CxbxMalloc(NumberOfBytes);

    return pRet;
}

// ******************************************************************
// * 0x00A9 - MmCreateKernelStack
// ******************************************************************
// * Differences from NT: Custom stack size.
// ******************************************************************
XBSYSAPI EXPORTNUM(169) xboxkrnl::PVOID NTAPI xboxkrnl::MmCreateKernelStack
(
    IN ULONG	NumberOfBytes,
    IN BOOLEAN  DebuggerThread
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(NumberOfBytes)
		LOG_FUNC_ARG(DebuggerThread)
		LOG_FUNC_END;
	
	NtDll::PVOID pRet = NULL;

    if (!NumberOfBytes) {
        // NumberOfBytes cannot be zero when passed to NtAllocateVirtualMemory() below
        CxbxKrnlCleanup("Assertion: 'NumberOfBytes != 0' in MmCreateKernelStack()");
    }

    if (NumberOfBytes & 0xFF) {
        // Validate NumberOfBytes for alignment with the page size
        CxbxKrnlCleanup("Assertion: '(NumberOfBytes & (PAGE_SIZE -1)) == 0' in MmCreateKernelStack()");
    }

    /**
     * Function at present does not:
     * - Create an additional guard PAGE_SIZE after allocation,
     * - Fill allocation with any values
     * - Treat DebuggerThread any differently
     */

	if(FAILED(NtDll::NtAllocateVirtualMemory(GetCurrentProcess(), &pRet, 0, &NumberOfBytes, MEM_COMMIT, PAGE_READWRITE)))
	    EmuWarning("MmCreateKernelStack failed!\n");
	else
		pRet = (PVOID)((ULONG)pRet + NumberOfBytes);

	return pRet;
}

// ******************************************************************
// * 0x00AA - MmDeleteKernelStack
// ******************************************************************
XBSYSAPI EXPORTNUM(170) VOID NTAPI xboxkrnl::MmDeleteKernelStack
(
    PVOID EndAddress,
    PVOID BaseAddress
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(EndAddress)
		LOG_FUNC_ARG(BaseAddress)
		LOG_FUNC_END;

   /* __asm int 3;
	CxbxKrnlCleanup( "MmDeleteKernelStack unimplemented (check call stack)" );*/
	ULONG RegionSize = 0;
    if (FAILED(NtDll::NtFreeVirtualMemory(GetCurrentProcess(), &BaseAddress, &RegionSize, MEM_RELEASE)))
        EmuWarning("MmDeleteKernelStack failed!\n");

    
}

// ******************************************************************
// * 0x00AB - MmFreeContiguousMemory
// ******************************************************************
XBSYSAPI EXPORTNUM(171) VOID NTAPI xboxkrnl::MmFreeContiguousMemory
(
    IN PVOID BaseAddress
)
{
	LOG_FUNC_ONE_ARG(BaseAddress);

    PVOID OrigBaseAddress = BaseAddress;

    if(g_AlignCache.exists(BaseAddress))
    {
        OrigBaseAddress = g_AlignCache.get(BaseAddress);

        g_AlignCache.remove(BaseAddress);
    }

    if(OrigBaseAddress != &xLaunchDataPage)
    {
        CxbxFree(OrigBaseAddress);
    }
    else
    {
        DbgPrintf("Ignored MmFreeContiguousMemory(&xLaunchDataPage)\n");
    }

    return;
}

// ******************************************************************
// * 0x00AC - MmFreeSystemMemory
// ******************************************************************
XBSYSAPI EXPORTNUM(172) xboxkrnl::NTSTATUS NTAPI xboxkrnl::MmFreeSystemMemory
(
    PVOID BaseAddress,
    ULONG NumberOfBytes
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(BaseAddress)
		LOG_FUNC_ARG(NumberOfBytes)
		LOG_FUNC_END;

    CxbxFree(BaseAddress);

    return STATUS_SUCCESS;
}

// ******************************************************************
// * 0x00AF - MmLockUnlockBufferPages
// ******************************************************************
XBSYSAPI EXPORTNUM(175) void NTAPI xboxkrnl::MmLockUnlockBufferPages
(
	IN PHYSICAL_ADDRESS	BaseAddress,
	IN ULONG			NumberOfBytes,
	IN ULONG			Protect
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(BaseAddress)
		LOG_FUNC_ARG(NumberOfBytes)
		LOG_FUNC_ARG(Protect)
		LOG_FUNC_END;

	EmuWarning("EmuKrnl: MmLockUnlockBufferPages ignored");
}

// ******************************************************************
// * 0x00B1 - MmMapIoSpace
// ******************************************************************
XBSYSAPI EXPORTNUM(177) xboxkrnl::PVOID NTAPI xboxkrnl::MmMapIoSpace
(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG            NumberOfBytes,
    IN ULONG            ProtectionType
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(PhysicalAddress)
		LOG_FUNC_ARG(NumberOfBytes)
		LOG_FUNC_ARG(ProtectionType)
		LOG_FUNC_END;

    // TODO: should this be aligned?
    PVOID pRet = CxbxMalloc(NumberOfBytes);

	return pRet;
}

// ******************************************************************
// * 0x00B2 - MmPersistContiguousMemory
// ******************************************************************
XBSYSAPI EXPORTNUM(178) VOID NTAPI xboxkrnl::MmPersistContiguousMemory
(
    IN PVOID   BaseAddress,
    IN ULONG   NumberOfBytes,
    IN BOOLEAN Persist
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(BaseAddress)
		LOG_FUNC_ARG(NumberOfBytes)
		LOG_FUNC_ARG(Persist)
		LOG_FUNC_END;

    // TODO: Actually set this up to be remember across a "reboot"
    EmuWarning("MmPersistContiguousMemory is being ignored\n");
}

// ******************************************************************
// * 0x00B4 - MmQueryAllocationSize
// ******************************************************************
XBSYSAPI EXPORTNUM(180) XTL::ULONG NTAPI xboxkrnl::MmQueryAllocationSize
(
    IN PVOID   BaseAddress
)
{
	LOG_FUNC_ONE_ARG(BaseAddress);

	ULONG uiSize = EmuCheckAllocationSize(BaseAddress, false);

	return uiSize;
}

// ******************************************************************
// * 0x00B5 - MmQueryStatistics
// ******************************************************************
XBSYSAPI EXPORTNUM(181) xboxkrnl::NTSTATUS NTAPI xboxkrnl::MmQueryStatistics
(
    OUT PMM_STATISTICS MemoryStatistics
)
{
	LOG_FUNC_ONE_ARG_OUT(MemoryStatistics);

    MEMORYSTATUS MemoryStatus;
    SYSTEM_INFO SysInfo;
    NTSTATUS ret;

    if (MemoryStatistics->Length == 0x24)
    {
        GlobalMemoryStatus(&MemoryStatus);
        GetSystemInfo(&SysInfo);

        /** 
        * When each of the PMM_STATISTICS MemoryStatistics elements
        * are setup correctly below, these two lines become redundant 
        */
        ZeroMemory(MemoryStatistics, sizeof(MM_STATISTICS));
        MemoryStatistics->Length = sizeof(MM_STATISTICS);

        MemoryStatistics->TotalPhysicalPages = MemoryStatus.dwTotalPhys / SysInfo.dwPageSize;
        MemoryStatistics->AvailablePages = MemoryStatus.dwAvailPhys / SysInfo.dwPageSize;
        MemoryStatistics->VirtualMemoryBytesCommitted = MemoryStatus.dwTotalVirtual - MemoryStatus.dwAvailVirtual;
        MemoryStatistics->VirtualMemoryBytesReserved = MemoryStatus.dwAvailVirtual;
        // MemoryStatistics->CachePagesCommitted = [ ];
        // MemoryStatistics->PoolPagesCommitted = [ ];
        // MemoryStatistics->StackPagesCommitted = [ ];
        // MemoryStatistics->ImagePagesCommitted = [ ];

        DbgPrintf("   MemoryStatistics->Length                      = 0x%.08X\n", MemoryStatistics->Length);
        DbgPrintf("   MemoryStatistics->TotalPhysicalPages          = 0x%.08X\n", MemoryStatistics->TotalPhysicalPages);
        DbgPrintf("   MemoryStatistics->AvailablePages              = 0x%.08X\n", MemoryStatistics->AvailablePages);
        DbgPrintf("   MemoryStatistics->VirtualMemoryBytesCommitted = 0x%.08X\n", MemoryStatistics->VirtualMemoryBytesCommitted);
        DbgPrintf("   MemoryStatistics->VirtualMemoryBytesReserved  = 0x%.08X\n", MemoryStatistics->VirtualMemoryBytesReserved);
        DbgPrintf("   MemoryStatistics->CachePagesCommitted         = 0x%.08X\n", MemoryStatistics->CachePagesCommitted);
        DbgPrintf("   MemoryStatistics->PoolPagesCommitted          = 0x%.08X\n", MemoryStatistics->PoolPagesCommitted);
        DbgPrintf("   MemoryStatistics->StackPagesCommitted         = 0x%.08X\n", MemoryStatistics->StackPagesCommitted);
        DbgPrintf("   MemoryStatistics->ImagePagesCommitted         = 0x%.08X\n", MemoryStatistics->ImagePagesCommitted);

        ret = STATUS_SUCCESS;
    } 
    else 
    {
        EmuWarning("EmuKrnl (0x%X): MmQueryStatistics with unusual size -> 0x%.08X\n", GetCurrentThreadId(), MemoryStatistics->Length);
        ret = STATUS_INVALID_PARAMETER;
    }

    

    return ret;
}

// ******************************************************************
// * 0x00B6 - MmSetAddressProtect
// ******************************************************************
XBSYSAPI EXPORTNUM(182) VOID NTAPI xboxkrnl::MmSetAddressProtect
(
    IN PVOID BaseAddress,
    IN ULONG NumberOfBytes,
    IN ULONG NewProtect
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(BaseAddress)
		LOG_FUNC_ARG(NumberOfBytes)
		LOG_FUNC_ARG(NewProtect)
		LOG_FUNC_END;

    DWORD dwOldProtect;

    if(!VirtualProtect(BaseAddress, NumberOfBytes, NewProtect & (~PAGE_WRITECOMBINE), &dwOldProtect))
        EmuWarning("VirtualProtect Failed!");

    DbgPrintf("EmuKrnl (0x%X): VirtualProtect was 0x%.08X -> 0x%.08X\n", GetCurrentThreadId(), dwOldProtect, NewProtect & (~PAGE_WRITECOMBINE));

    return;
}

// ******************************************************************
// * 0x00B7 - MmUnmapIoSpace
// ******************************************************************
XBSYSAPI EXPORTNUM(183) xboxkrnl::NTSTATUS NTAPI xboxkrnl::MmUnmapIoSpace
(
    IN PVOID BaseAddress,
    IN ULONG NumberOfBytes
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(BaseAddress)
		LOG_FUNC_ARG(NumberOfBytes)
		LOG_FUNC_END;

	CxbxFree(BaseAddress);

	return STATUS_SUCCESS;
}

// ******************************************************************
// * 0x00B8 - NtAllocateVirtualMemory
// ******************************************************************
XBSYSAPI EXPORTNUM(184) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtAllocateVirtualMemory
(
    IN OUT PVOID    *BaseAddress,
    IN ULONG         ZeroBits,
    IN OUT PULONG    AllocationSize,
    IN DWORD         AllocationType,
    IN DWORD         Protect
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(BaseAddress)
		LOG_FUNC_ARG(ZeroBits)
		LOG_FUNC_ARG(AllocationSize)
		LOG_FUNC_ARG(AllocationType)
		LOG_FUNC_ARG(Protect)
		LOG_FUNC_END;
	
	// TODO: The flag known as MEM_NOZERO (which appears to be exclusive to Xbox) has the exact
	// same value as MEM_ROTATE which causes problems for Windows XP, but not Vista.  Removing
	// this flag fixes Azurik for XP.
	DWORD MEM_NOZERO = 0x800000;

	if( AllocationType & MEM_NOZERO )
	{
		EmuWarning( "MEM_NOZERO flag is not supported!" );
		AllocationType &= ~MEM_NOZERO;
	}

    NTSTATUS ret = NtDll::NtAllocateVirtualMemory(GetCurrentProcess(), BaseAddress, ZeroBits, AllocationSize, AllocationType, Protect);
	if( ret == 0xC00000F3 )
		EmuWarning( "Invalid Param!" );

	return ret;
}

// ******************************************************************
// * 0x00BA - NtClearEvent
// ******************************************************************
XBSYSAPI EXPORTNUM(186) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtClearEvent
(
    IN HANDLE EventHandle
)
{
	LOG_FUNC_ONE_ARG(EventHandle);

    NTSTATUS ret = NtDll::NtClearEvent(EventHandle);

    if(FAILED(ret))
        EmuWarning("NtClearEvent Failed!");

    return ret;
}

// ******************************************************************
// * 0x00BB - NtClose
// ******************************************************************
XBSYSAPI EXPORTNUM(187) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtClose
(
    IN HANDLE Handle
)
{
	LOG_FUNC_ONE_ARG(Handle);

    NTSTATUS ret = STATUS_SUCCESS;

    // delete 'special' handles
    if(IsEmuHandle(Handle))
    {
        EmuHandle *iEmuHandle = HandleToEmuHandle(Handle);
		ret = iEmuHandle->NtClose();
    }
    // close normal handles
    else
    {
        ret = NtDll::NtClose(Handle);
    }

    return ret;
}

// ******************************************************************
// * 0x00BC - NtCreateDirectoryObject
// ******************************************************************
XBSYSAPI EXPORTNUM(188) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtCreateDirectoryObject
(
	OUT PHANDLE             DirectoryHandle,
	IN  POBJECT_ATTRIBUTES  ObjectAttributes
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG_OUT(DirectoryHandle)
		LOG_FUNC_ARG(ObjectAttributes)
		LOG_FUNC_END;

	NTSTATUS ret = 0;

	NativeObjectAttributes nativeObjectAttributes;
	ACCESS_MASK DesiredAccess = 0;

	ret = CxbxObjectAttributesToNT(ObjectAttributes, nativeObjectAttributes, "NtCreateDirectoryObject"); 
	if (ret == STATUS_SUCCESS)
	{
		// TODO -oDxbx : Is this the correct ACCESS_MASK? :
		DesiredAccess = DIRECTORY_CREATE_OBJECT;

		ret = /*# JwaNative::*/ NtDll::NtCreateDirectoryObject(DirectoryHandle, DesiredAccess, nativeObjectAttributes.NtObjAttrPtr);
	}

	if (FAILED(ret))
		EmuWarning("NtCreateDirectoryObject Failed!");

	DbgPrintf("EmuKrnl (0x%X): NtCreateDirectoryObject DirectoryHandle = 0x%.08X\n", GetCurrentThreadId(), *DirectoryHandle);

	return ret;
}


// ******************************************************************
// * 0x00BD - NtCreateEvent
// ******************************************************************
XBSYSAPI EXPORTNUM(189) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtCreateEvent
(
    OUT PHANDLE             EventHandle,
    IN  POBJECT_ATTRIBUTES  ObjectAttributes OPTIONAL,
    IN  EVENT_TYPE          EventType,
    IN  BOOLEAN             InitialState
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG_OUT(EventHandle)
		LOG_FUNC_ARG(ObjectAttributes)
		LOG_FUNC_ARG(EventType)
		LOG_FUNC_ARG(InitialState)
		LOG_FUNC_END;

	NativeObjectAttributes nativeObjectAttributes;
	ACCESS_MASK DesiredAccess = 0;

	// initialize object attributes
	NTSTATUS ret = CxbxObjectAttributesToNT(ObjectAttributes, nativeObjectAttributes); /*var*/
	if (ret == STATUS_SUCCESS)
	{
		// TODO -oDxbx : Is this the correct ACCESS_MASK? :
		DesiredAccess = EVENT_ALL_ACCESS;

		// redirect to Win2k/XP
		ret = NtDll::NtCreateEvent(EventHandle, DesiredAccess, nativeObjectAttributes.NtObjAttrPtr, (NtDll::EVENT_TYPE)EventType, InitialState);
		// TODO : Instead of the above, we should consider using the Ke*Event APIs, but
		// that would require us to create the event's kernel object with the Ob* api's too!
	}

    if(FAILED(ret))
        EmuWarning("NtCreateEvent Failed!");

    DbgPrintf("EmuKrnl (0x%X): NtCreateEvent EventHandle = 0x%.08X\n", GetCurrentThreadId(), *EventHandle);

    return ret;
}

// ******************************************************************
// * 0x00BE - NtCreateFile
// ******************************************************************
XBSYSAPI EXPORTNUM(190) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtCreateFile
(
    OUT PHANDLE             FileHandle,
    IN  ACCESS_MASK         DesiredAccess,
    IN  POBJECT_ATTRIBUTES  ObjectAttributes,
    OUT PIO_STATUS_BLOCK    IoStatusBlock,
    IN  PLARGE_INTEGER      AllocationSize OPTIONAL,
    IN  ULONG               FileAttributes,
    IN  ULONG               ShareAccess,
    IN  ULONG               CreateDisposition,
    IN  ULONG               CreateOptions
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG_OUT(FileHandle)
		LOG_FUNC_ARG(DesiredAccess)
		LOG_FUNC_ARG(ObjectAttributes)
		LOG_FUNC_ARG_OUT(IoStatusBlock)
		LOG_FUNC_ARG(AllocationSize)
		LOG_FUNC_ARG(FileAttributes)
		LOG_FUNC_ARG(ShareAccess)
		LOG_FUNC_ARG(CreateDisposition)
		LOG_FUNC_ARG(CreateOptions)
		LOG_FUNC_END;

	NativeObjectAttributes nativeObjectAttributes;

	NTSTATUS ret = CxbxObjectAttributesToNT(ObjectAttributes, nativeObjectAttributes, "NtCreateFile"); /*var*/
    // redirect to NtCreateFile
	ret = NtDll::NtCreateFile(FileHandle, DesiredAccess | GENERIC_READ, nativeObjectAttributes.NtObjAttrPtr, NtDll::PIO_STATUS_BLOCK(IoStatusBlock), NtDll::PLARGE_INTEGER(AllocationSize), FileAttributes, ShareAccess, CreateDisposition, CreateOptions, NULL, 0); 
    
    if(FAILED(ret))
    {
        DbgPrintf("EmuKrnl (0x%X): NtCreateFile Failed! (0x%.08X)\n", GetCurrentThreadId(), ret);
    }
    else
    {
        DbgPrintf("EmuKrnl (0x%X): NtCreateFile = 0x%.08X\n", GetCurrentThreadId(), *FileHandle);
    }

 
    // NOTE: We can map this to IoCreateFile once implemented (if ever necessary)
    //       xboxkrnl::IoCreateFile(FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, AllocationSize, FileAttributes, ShareAccess, CreateDisposition, CreateOptions, 0);

    

    return ret;
}

// ******************************************************************
// * 0x00C0 - NtCreateMutant
// ******************************************************************
XBSYSAPI EXPORTNUM(192) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtCreateMutant
(
    OUT PHANDLE             MutantHandle,
    IN  POBJECT_ATTRIBUTES  ObjectAttributes,
    IN  BOOLEAN             InitialOwner
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG_OUT(MutantHandle)
		LOG_FUNC_ARG(ObjectAttributes)
		LOG_FUNC_ARG(InitialOwner)
		LOG_FUNC_END;

	char *szBuffer = (ObjectAttributes != 0) ? ObjectAttributes->ObjectName->Buffer : 0;
	wchar_t wszObjectName[160];

    NtDll::UNICODE_STRING    NtUnicodeString;
    NtDll::OBJECT_ATTRIBUTES NtObjAttr;

    // initialize object attributes
    if(szBuffer != 0)
    {
        mbstowcs(wszObjectName, "\\??\\", 4);
        mbstowcs(wszObjectName+4, szBuffer, 160);

        NtDll::RtlInitUnicodeString(&NtUnicodeString, wszObjectName);

        InitializeObjectAttributes(&NtObjAttr, &NtUnicodeString, ObjectAttributes->Attributes, ObjectAttributes->RootDirectory, NULL);
    }

    NtObjAttr.RootDirectory = 0;

    // redirect to NtCreateMutant
    NTSTATUS ret = NtDll::NtCreateMutant(MutantHandle, MUTANT_ALL_ACCESS, (szBuffer != 0) ? &NtObjAttr : 0, InitialOwner);

    if(FAILED(ret))
        EmuWarning("NtCreateMutant Failed!");

    DbgPrintf("EmuKrnl (0x%X): NtCreateMutant MutantHandle = 0x%.08X\n", GetCurrentThreadId(), *MutantHandle);
	
	return ret;
}

// ******************************************************************
// * 0x00C1 - NtCreateSemaphore
// ******************************************************************
XBSYSAPI EXPORTNUM(193) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtCreateSemaphore
(
    OUT PHANDLE             SemaphoreHandle,
    IN  POBJECT_ATTRIBUTES  ObjectAttributes,
    IN  ULONG               InitialCount,
    IN  ULONG               MaximumCount
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG_OUT(SemaphoreHandle)
		LOG_FUNC_ARG(ObjectAttributes)
		LOG_FUNC_ARG(InitialCount)
		LOG_FUNC_ARG(MaximumCount)
		LOG_FUNC_END;

    // redirect to Win2k/XP
    NTSTATUS ret = NtDll::NtCreateSemaphore
    (
        SemaphoreHandle,
        SEMAPHORE_ALL_ACCESS,
        (NtDll::POBJECT_ATTRIBUTES)ObjectAttributes,
        InitialCount,
        MaximumCount
    );

    if(FAILED(ret))
        EmuWarning("NtCreateSemaphore failed!");

    DbgPrintf("EmuKrnl (0x%X): NtCreateSemaphore SemaphoreHandle = 0x%.08X\n", GetCurrentThreadId(), *SemaphoreHandle);

    return ret;
}

XBSYSAPI EXPORTNUM(196) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtDeviceIoControlFile
(
	IN HANDLE FileHandle,
	IN HANDLE Event OPTIONAL,
	IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
	IN PVOID ApcContext OPTIONAL,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN ULONG IoControlCode,
	IN PVOID InputBuffer OPTIONAL,
	IN ULONG InputBufferLength,
	OUT PVOID OutputBuffer OPTIONAL,
	IN ULONG OutputBufferLength
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(FileHandle)
		LOG_FUNC_ARG(Event)
		LOG_FUNC_ARG(ApcRoutine)
		LOG_FUNC_ARG(ApcContext)
		LOG_FUNC_ARG_OUT(IoStatusBlock)
		LOG_FUNC_ARG(IoControlCode)
		LOG_FUNC_ARG(InputBuffer)
		LOG_FUNC_ARG(InputBufferLength)
		LOG_FUNC_ARG_OUT(OutputBuffer)
		LOG_FUNC_ARG(OutputBufferLength)
		LOG_FUNC_END;

	switch (IoControlCode)
	{
	// IOCTL_SCSI_PASS_THROUGH_DIRECT
	case 0x4D014:
	{
		PSCSI_PASS_THROUGH_DIRECT PassThrough = (PSCSI_PASS_THROUGH_DIRECT)InputBuffer;
		PDVDX2_AUTHENTICATION Authentication = (PDVDX2_AUTHENTICATION)PassThrough->DataBuffer;

		// Should be just enough info to pass XapiVerifyMediaInDrive
		Authentication->AuthenticationPage.CDFValid = 1;
		Authentication->AuthenticationPage.PartitionArea = 1;
		Authentication->AuthenticationPage.Authentication = 1;
		break;
	}
	default:
		CxbxKrnlCleanup("NtDeviceIoControlFile Not Implemented");
	}

	return STATUS_SUCCESS;
}

// ******************************************************************
// * 0x00C5 - NtDuplicateObject
// ******************************************************************
XBSYSAPI EXPORTNUM(197) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtDuplicateObject
(
    HANDLE  SourceHandle,
    HANDLE *TargetHandle,
    DWORD   Options
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(SourceHandle)
		LOG_FUNC_ARG(TargetHandle)
		LOG_FUNC_ARG(Options)
		LOG_FUNC_END;

	NTSTATUS ret;

	if (IsEmuHandle(SourceHandle)) {
		EmuHandle* iEmuHandle = HandleToEmuHandle(SourceHandle);
		ret = iEmuHandle->NtDuplicateObject(TargetHandle, Options);
	}
	else {
		// redirect to Win2k/XP
		ret = NtDll::NtDuplicateObject
		(
			GetCurrentProcess(),
			SourceHandle,
			GetCurrentProcess(),
			TargetHandle,
			0, 0, Options
		);
	}

	if(ret != STATUS_SUCCESS)
        EmuWarning("Object was not duplicated!");

	return ret;
}

// ******************************************************************
// * NtFlushBuffersFile
// ******************************************************************
XBSYSAPI EXPORTNUM(198) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtFlushBuffersFile
(
    PVOID                FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(FileHandle)
		LOG_FUNC_ARG_OUT(IoStatusBlock)
		LOG_FUNC_END;

    NTSTATUS ret = NtDll::NtFlushBuffersFile(FileHandle, (NtDll::IO_STATUS_BLOCK*)IoStatusBlock);

	return ret;
}

// ******************************************************************
// * 0x00C7 - NtFreeVirtualMemory
// ******************************************************************
XBSYSAPI EXPORTNUM(199) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtFreeVirtualMemory
(
    IN OUT PVOID *BaseAddress,
    IN OUT PULONG FreeSize,
    IN ULONG      FreeType
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(BaseAddress)
		LOG_FUNC_ARG(FreeSize)
		LOG_FUNC_ARG(FreeType)
		LOG_FUNC_END;

    NTSTATUS ret = NtDll::NtFreeVirtualMemory(GetCurrentProcess(), BaseAddress, FreeSize, FreeType);

	return ret;
}

// ******************************************************************
// * 0x00CA - NtOpenFile
// ******************************************************************
XBSYSAPI EXPORTNUM(202) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtOpenFile
(
    OUT PHANDLE             FileHandle,
    IN  ACCESS_MASK         DesiredAccess,
    IN  POBJECT_ATTRIBUTES  ObjectAttributes,
    OUT PIO_STATUS_BLOCK    IoStatusBlock,
    IN  ULONG               ShareAccess,
    IN  ULONG               OpenOptions
)
{
    /* Redundant
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG_OUT(FileHandle)
		LOG_FUNC_ARG(DesiredAccess)
		LOG_FUNC_ARG(ObjectAttributes)
		LOG_FUNC_ARG_OUT(IoStatusBlock)
		LOG_FUNC_ARG(ShareAccess)
		LOG_FUNC_ARG(OpenOptions)
		LOG_FUNC_END;
        
    //*/

    return NtCreateFile(FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, NULL, 0, ShareAccess, FILE_OPEN, OpenOptions);
}


// ******************************************************************
// * 0x00CB - NtOpenSymbolicLinkObject
// ******************************************************************
XBSYSAPI EXPORTNUM(203) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtOpenSymbolicLinkObject
(
	OUT PHANDLE LinkHandle,
	IN POBJECT_ATTRIBUTES ObjectAttributes
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG_OUT(LinkHandle)
		LOG_FUNC_ARG(ObjectAttributes)
		LOG_FUNC_END;

	NTSTATUS ret = 0;
	EmuNtSymbolicLinkObject* symbolicLinkObject = NULL;

	symbolicLinkObject = FindNtSymbolicLinkObjectByName(std::string(ObjectAttributes->ObjectName->Buffer, ObjectAttributes->ObjectName->Length));
	if (symbolicLinkObject != NULL)
	{
		// Return a new handle
		*LinkHandle = symbolicLinkObject->NewHandle();
		ret = STATUS_SUCCESS;
	}
	else
	if (ret != STATUS_SUCCESS)
		EmuWarning("NtOpenSymbolicLinkObject failed! (%s)", (NtStatusToString(ret)));
	else
		DbgPrintf("EmuKrnl : NtOpenSymbolicLinkObject LinkHandle^ = 0x%.08X", *LinkHandle);

	return ret;
}

// ******************************************************************
// * 0x00CC - NtProtectVirtualMemory
// ******************************************************************
XBSYSAPI EXPORTNUM(205) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtProtectVirtualMemory
(
	IN OUT PVOID *BaseAddress,
	IN OUT PSIZE_T RegionSize,
	IN ULONG NewProtect,
	OUT PULONG OldProtect
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(BaseAddress)
		LOG_FUNC_ARG(RegionSize)
		LOG_FUNC_ARG(NewProtect)
		LOG_FUNC_ARG_OUT(OldProtect)
		LOG_FUNC_END;

	EmuWarning("NtProtectVirtualMemory Ignored!");

	return STATUS_SUCCESS;
}

// ******************************************************************
// * 0x00CE - NtQueueApcThread
// ******************************************************************
XBSYSAPI EXPORTNUM(206) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtQueueApcThread
(
	IN HANDLE               ThreadHandle,
	IN PIO_APC_ROUTINE      ApcRoutine,
	IN PVOID                ApcRoutineContext OPTIONAL,
	IN PIO_STATUS_BLOCK     ApcStatusBlock OPTIONAL,
	IN ULONG                ApcReserved OPTIONAL 
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(ThreadHandle)
		LOG_FUNC_ARG(ApcRoutine)
		LOG_FUNC_ARG(ApcRoutineContext)
		LOG_FUNC_ARG(ApcStatusBlock)
		LOG_FUNC_ARG(ApcReserved)
		LOG_FUNC_END;

	NTSTATUS ret;

	// TODO: Not too sure how this one works.  If there's any special *magic* that needs to be
	//		 done, let me know!
	ret = NtDll::NtQueueApcThread( (NtDll::HANDLE) ThreadHandle, (NtDll::PIO_APC_ROUTINE) ApcRoutine, ApcRoutineContext, 
									(NtDll::PIO_STATUS_BLOCK) ApcStatusBlock, ApcReserved );
	if( FAILED( ret ) )
		EmuWarning( "NtQueueApcThread failed!" );

	return ret;
}

// ******************************************************************
// * 0x00CF - NtQueryDirectoryFile
// ******************************************************************
XBSYSAPI EXPORTNUM(207) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtQueryDirectoryFile
(
    IN  HANDLE                      FileHandle,
    IN  HANDLE                      Event OPTIONAL,
    IN  PVOID                       ApcRoutine, // Todo: define this routine's prototype
    IN  PVOID                       ApcContext,
    OUT PIO_STATUS_BLOCK            IoStatusBlock,
    OUT FILE_DIRECTORY_INFORMATION *FileInformation,
    IN  ULONG                       Length,
    IN  FILE_INFORMATION_CLASS      FileInformationClass,
    IN  PSTRING                     FileMask,
    IN  BOOLEAN                     RestartScan
)
{
	LOG_FUNC_BEGIN 
		LOG_FUNC_ARG(FileHandle)
		LOG_FUNC_ARG(Event)
		LOG_FUNC_ARG(ApcRoutine)
		LOG_FUNC_ARG(ApcContext)
		LOG_FUNC_ARG_OUT(IoStatusBlock)
		LOG_FUNC_ARG_OUT(FileInformation)
		LOG_FUNC_ARG(Length)
		LOG_FUNC_ARG(FileInformationClass)
		LOG_FUNC_ARG(FileMask)
		LOG_FUNC_ARG(RestartScan)
		LOG_FUNC_END;

    NTSTATUS ret;

    if(FileInformationClass != 1)   // Due to unicode->string conversion
        CxbxKrnlCleanup("Unsupported FileInformationClass");

    NtDll::UNICODE_STRING NtFileMask;

    wchar_t wszObjectName[160];

    // initialize FileMask
    {
        if(FileMask != 0)
            mbstowcs(wszObjectName, FileMask->Buffer, 160);
        else
            mbstowcs(wszObjectName, "", 160);

        NtDll::RtlInitUnicodeString(&NtFileMask, wszObjectName);
    }

    NtDll::FILE_DIRECTORY_INFORMATION *FileDirInfo = (NtDll::FILE_DIRECTORY_INFORMATION*)CxbxMalloc(0x40 + 160*2);

    char    *mbstr = FileInformation->FileName;
    wchar_t *wcstr = FileDirInfo->FileName;

    do
    {
        ZeroMemory(wcstr, 160*2);

        ret = NtDll::NtQueryDirectoryFile
        (
            FileHandle, Event, (NtDll::PIO_APC_ROUTINE)ApcRoutine, ApcContext, (NtDll::IO_STATUS_BLOCK*)IoStatusBlock, FileDirInfo,
            0x40+160*2, (NtDll::FILE_INFORMATION_CLASS)FileInformationClass, TRUE, &NtFileMask, RestartScan
        );

        // convert from PC to Xbox
        {
            memcpy(FileInformation, FileDirInfo, 0x40);

            wcstombs(mbstr, wcstr, 160);

            FileInformation->FileNameLength /= 2;
        }

        RestartScan = FALSE;
    }
    // Xbox does not return . and ..
    while(strcmp(mbstr, ".") == 0 || strcmp(mbstr, "..") == 0);

    // TODO: Cache the last search result for quicker access with CreateFile (xbox does this internally!)
    CxbxFree(FileDirInfo);

	return ret;
}

// ******************************************************************
// * 0x00D2 - NtQueryFullAttributesFile
// ******************************************************************
XBSYSAPI EXPORTNUM(210) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtQueryFullAttributesFile
(
    IN  POBJECT_ATTRIBUTES          ObjectAttributes,
    OUT PVOID                       Attributes
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(ObjectAttributes)
		LOG_FUNC_ARG_OUT(Attributes)
		LOG_FUNC_END;

//	__asm int 3;
	NativeObjectAttributes nativeObjectAttributes;
	NTSTATUS ret = CxbxObjectAttributesToNT(ObjectAttributes, nativeObjectAttributes, "NtQueryFullAttributesFile"); /*var*/
	
	if (ret == STATUS_SUCCESS)
		ret = NtDll::NtQueryFullAttributesFile(nativeObjectAttributes.NtObjAttrPtr, Attributes);

	if(FAILED(ret))
		EmuWarning("NtQueryFullAttributesFile failed! (0x%.08X)\n", ret);

	return ret;
}

// ******************************************************************
// * 0x00D3 - NtQueryInformationFile
// ******************************************************************
XBSYSAPI EXPORTNUM(211) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtQueryInformationFile
(
    IN  HANDLE                      FileHandle,
    OUT PIO_STATUS_BLOCK            IoStatusBlock,
    OUT PVOID                       FileInformation,
    IN  ULONG                       Length,
    IN  FILE_INFORMATION_CLASS      FileInfo
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(FileHandle)
		LOG_FUNC_ARG_OUT(IoStatusBlock)
		LOG_FUNC_ARG_OUT(FileInformation)
		LOG_FUNC_ARG(Length)
		LOG_FUNC_ARG(FileInfo)
		LOG_FUNC_END;

	// TODO: IIRC, this function is depreciated.  Maybe we should just use
	// ZwQueryInformationFile instead?

//    if(FileInfo != FilePositionInformation && FileInfo != FileNetworkOpenInformation)
//        CxbxKrnlCleanup("Unknown FILE_INFORMATION_CLASS 0x%.08X", FileInfo);

    NTSTATUS ret = NtDll::NtQueryInformationFile
    (
        FileHandle,
        (NtDll::PIO_STATUS_BLOCK)IoStatusBlock,
        (NtDll::PFILE_FS_SIZE_INFORMATION)FileInformation,
        Length,
        (NtDll::FILE_INFORMATION_CLASS)FileInfo
    );

    //
    // DEBUGGING!
    //
    {
        /*
        _asm int 3;
        NtDll::FILE_NETWORK_OPEN_INFORMATION *pInfo = (NtDll::FILE_NETWORK_OPEN_INFORMATION*)FileInformation;

        if(FileInfo == FileNetworkOpenInformation && (pInfo->AllocationSize.LowPart == 57344))
        {
            DbgPrintf("pInfo->AllocationSize : %d\n", pInfo->AllocationSize.LowPart);
            DbgPrintf("pInfo->EndOfFile      : %d\n", pInfo->EndOfFile.LowPart);

            pInfo->EndOfFile.LowPart = 0x1000;
            pInfo->AllocationSize.LowPart = 0x1000;

            fflush(stdout);
        }
        */
    }

    if(FAILED(ret))
        EmuWarning("NtQueryInformationFile failed! (0x%.08X)", ret);

	return ret;
}

// ******************************************************************
// * 0x00D7 - NtQuerySymbolicLinkObject
// ******************************************************************
XBSYSAPI EXPORTNUM(215) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtQuerySymbolicLinkObject
(
	HANDLE LinkHandle,
	OUT PSTRING LinkTarget,
	OUT PULONG ReturnedLength OPTIONAL
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(LinkHandle)
		LOG_FUNC_ARG_OUT(LinkTarget)
		LOG_FUNC_ARG_OUT(ReturnedLength)
		LOG_FUNC_END;

	NTSTATUS result = 0;
	EmuNtSymbolicLinkObject* symbolicLinkObject = NULL;

	// Check that we actually got an EmuHandle :
	result = STATUS_INVALID_HANDLE;

	EmuHandle* iEmuHandle = HandleToEmuHandle(LinkHandle);
	// Retrieve the NtSymbolicLinkObject and populate the output arguments :
	result = STATUS_SUCCESS;
	symbolicLinkObject = (EmuNtSymbolicLinkObject*)iEmuHandle->NtObject;
	if (LinkTarget != NULL)
	{
		if (LinkTarget->Length > LinkTarget->MaximumLength) 
		{
			result = STATUS_BUFFER_TOO_SMALL;
			LinkTarget->Length = LinkTarget->MaximumLength;
		}

		memcpy(LinkTarget->Buffer, symbolicLinkObject->XboxFullPath.c_str(), LinkTarget->Length);
	}

	if (ReturnedLength != NULL)
	{
		*ReturnedLength = symbolicLinkObject->XboxFullPath.length(); // Return full length (even if buffer was too small)
	}

	if (result != STATUS_SUCCESS)
		EmuWarning("NtQuerySymbolicLinkObject failed! (%s)", NtStatusToString(result));

	return result;
}


// ******************************************************************
// * 0x00D9 - NtQueryVirtualMemory
// ******************************************************************
XBSYSAPI EXPORTNUM(217) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtQueryVirtualMemory
(
    IN  PVOID                       BaseAddress,
    OUT PMEMORY_BASIC_INFORMATION   Buffer
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(BaseAddress)
		LOG_FUNC_ARG_OUT(Buffer)
		LOG_FUNC_END;

    NTSTATUS ret = NtDll::NtQueryVirtualMemory
    (
        GetCurrentProcess(),
        BaseAddress,
        (NtDll::MEMORY_INFORMATION_CLASS)NtDll::MemoryBasicInformation,
        (NtDll::PMEMORY_BASIC_INFORMATION)Buffer,
        sizeof(MEMORY_BASIC_INFORMATION),
        0
    );

    if(FAILED(ret)) {
        EmuWarning("NtQueryVirtualMemory failed (%s)!", NtStatusToString(ret));

        // Bugfix for "Forza Motorsport", which iterates over 2 Gb of memory in 64kb chunks,
        // but fails on this last query. It's not done though, as after this Forza tries to
        // NtAllocateVirtualMemory at address 0x00000000 (3 times, actually) which fails too...
        //
        // Ported back from dxbx, translator PatrickvL
        
        if (BaseAddress == (PVOID)0x7FFF0000) {
            Buffer->BaseAddress = BaseAddress;
            Buffer->AllocationBase = BaseAddress;
            Buffer->AllocationProtect = PAGE_READONLY;
            Buffer->RegionSize = 64 * 1024;             // size, in bytes, of the region beginning at the base address in which all pages have identical attributes
            Buffer->State = 4096;                       // MEM_DECOMMIT | PAGE_EXECUTE_WRITECOPY etc
            Buffer->Protect = PAGE_READONLY;            // One of the flags listed for the AllocationProtect member is specified
            Buffer->Type = 262144;                      // Specifies the type of pages in the region. (MEM_IMAGE, MEM_MAPPED or MEM_PRIVATE)

            ret = STATUS_SUCCESS;

            DbgPrintf("EmuKrnl (0x%X): NtQueryVirtualMemory: Applied fix for Forza Motorsport!\n", GetCurrentThreadId());
        }
    }

	return ret;
}

// ******************************************************************
// * 0x00DA - NtQueryVolumeInformationFile
// ******************************************************************
XBSYSAPI EXPORTNUM(218) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtQueryVolumeInformationFile
(
    IN  HANDLE                      FileHandle,
    OUT PIO_STATUS_BLOCK            IoStatusBlock,
    OUT PFILE_FS_SIZE_INFORMATION   FileInformation,
    IN  ULONG                       Length,
    IN  FS_INFORMATION_CLASS        FileInformationClass
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(FileHandle)
		LOG_FUNC_ARG_OUT(IoStatusBlock)
		LOG_FUNC_ARG_OUT(FileInformation)
		LOG_FUNC_ARG(Length)
		LOG_FUNC_ARG(FileInformationClass)
		LOG_FUNC_END;

    NTSTATUS ret = NtDll::NtQueryVolumeInformationFile
    (
        FileHandle,
        (NtDll::PIO_STATUS_BLOCK)IoStatusBlock,
        (NtDll::PFILE_FS_SIZE_INFORMATION)FileInformation, Length,
        (NtDll::FS_INFORMATION_CLASS)FileInformationClass
    );

	if (ret == STATUS_SUCCESS)
	{
		// NOTE: TODO: Dynamically fill in, or allow configuration?
		if (FileInformationClass == FileFsSizeInformation)
		{
			FILE_FS_SIZE_INFORMATION *SizeInfo = (FILE_FS_SIZE_INFORMATION*)FileInformation;

			SizeInfo->TotalAllocationUnits.QuadPart = 0x4C468;
			SizeInfo->AvailableAllocationUnits.QuadPart = 0x2F125;
			SizeInfo->SectorsPerAllocationUnit = 32;
			SizeInfo->BytesPerSector = 512;
		}

	} 
	else
	{
		EmuWarning("NtQueryVolumeInformationFile failed! (%s)\n", NtStatusToString(ret));
	}

	return ret;
}

// ******************************************************************
// * 0x00DA - NtReadFile
// ******************************************************************
XBSYSAPI EXPORTNUM(219) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtReadFile
(
    IN  HANDLE          FileHandle,            // TODO: correct paramters
    IN  HANDLE          Event OPTIONAL,
    IN  PVOID           ApcRoutine OPTIONAL,
    IN  PVOID           ApcContext,
    OUT PVOID           IoStatusBlock,
    OUT PVOID           Buffer,
    IN  ULONG           Length,
    IN  PLARGE_INTEGER  ByteOffset OPTIONAL
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(FileHandle)
		LOG_FUNC_ARG(Event)
		LOG_FUNC_ARG(ApcRoutine)
		LOG_FUNC_ARG(ApcContext)
		LOG_FUNC_ARG_OUT(IoStatusBlock)
		LOG_FUNC_ARG_OUT(Buffer)
		LOG_FUNC_ARG(Length)
		LOG_FUNC_ARG(ByteOffset)
		LOG_FUNC_END;

// Halo...
//    if(ByteOffset != 0 && ByteOffset->QuadPart == 0x00120800)
//        _asm int 3

    NTSTATUS ret = NtDll::NtReadFile(FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, Buffer, Length, (NtDll::LARGE_INTEGER*)ByteOffset, 0);

    if(FAILED(ret))
		EmuWarning("NtReadFile Failed! (0x%.08X)", ret);

	return ret;
}

// ******************************************************************
// * 0x00DD - NtReleaseMutant
// ******************************************************************
XBSYSAPI EXPORTNUM(221) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtReleaseMutant
(
    IN  HANDLE  MutantHandle,
    OUT PLONG   PreviousCount
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(MutantHandle)
		LOG_FUNC_ARG_OUT(PreviousCount)
		LOG_FUNC_END;

    // redirect to NtCreateMutant
    NTSTATUS ret = NtDll::NtReleaseMutant(MutantHandle, PreviousCount);

    if(FAILED(ret))
        EmuWarning("NtReleaseMutant Failed!");

	return STATUS_SUCCESS;
}

// ******************************************************************
// * 0x00DE - NtReleaseSemaphore
// ******************************************************************
XBSYSAPI EXPORTNUM(222) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtReleaseSemaphore
(
    IN  HANDLE              SemaphoreHandle,
    IN  ULONG               ReleaseCount,
    OUT PULONG              PreviousCount
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(SemaphoreHandle)
		LOG_FUNC_ARG(ReleaseCount)
		LOG_FUNC_ARG_OUT(PreviousCount)
		LOG_FUNC_END;

    NTSTATUS ret = NtDll::NtReleaseSemaphore(SemaphoreHandle, ReleaseCount, PreviousCount);

    if(FAILED(ret))
        EmuWarning("NtReleaseSemaphore failed!");

	return ret;
}

// ******************************************************************
// * 0x00E0 - NtResumeThread
// ******************************************************************
XBSYSAPI EXPORTNUM(224) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtResumeThread
(
    IN  HANDLE ThreadHandle,
    OUT PULONG PreviousSuspendCount
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(ThreadHandle)
		LOG_FUNC_ARG_OUT(PreviousSuspendCount)
		LOG_FUNC_END;

    NTSTATUS ret = NtDll::NtResumeThread(ThreadHandle, PreviousSuspendCount);

    Sleep(10);

	return ret;
}

// ******************************************************************
// * 0x00E1 - NtSetEvent
// ******************************************************************
XBSYSAPI EXPORTNUM(225) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtSetEvent
(
    IN  HANDLE EventHandle,
    OUT PLONG  PreviousState
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(EventHandle)
		LOG_FUNC_ARG_OUT(PreviousState)
		LOG_FUNC_END;

    NTSTATUS ret = NtDll::NtSetEvent(EventHandle, PreviousState);

    if(FAILED(ret))
        EmuWarning("NtSetEvent Failed!");

	return ret;
}

// ******************************************************************
// * 0x00E2 - NtSetInformationFile
// ******************************************************************
XBSYSAPI EXPORTNUM(226) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtSetInformationFile
(
    IN  HANDLE  FileHandle,            // TODO: correct paramters
    OUT PVOID   IoStatusBlock,
    IN  PVOID   FileInformation,
    IN  ULONG   Length,
    IN  ULONG   FileInformationClass
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(FileHandle)
		LOG_FUNC_ARG_OUT(IoStatusBlock)
		LOG_FUNC_ARG(FileInformation)
		LOG_FUNC_ARG(Length)
		LOG_FUNC_ARG(FileInformationClass)
		LOG_FUNC_END;

    NTSTATUS ret = NtDll::NtSetInformationFile(FileHandle, IoStatusBlock, FileInformation, Length, FileInformationClass);

    return ret;
}

// ******************************************************************
// * 0x00E4 - NtSetSystemTime
// ******************************************************************
XBSYSAPI EXPORTNUM(228) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtSetSystemTime
(
	IN  PLARGE_INTEGER			SystemTime,
	OUT PLARGE_INTEGER			PreviousTime OPTIONAL 
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(SystemTime)
		LOG_FUNC_ARG_OUT(PreviousTime)
		LOG_FUNC_END;

	// Maybe it's not such a good idea to allow Cxbx to change your time 
	// clock.  Might need admin privileges to do this.... dunno.

    NTSTATUS ret = STATUS_SUCCESS;

    return ret;
}

// ******************************************************************
// * 0x00E7 - NtSuspendThread
// ******************************************************************
XBSYSAPI EXPORTNUM(231) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtSuspendThread
(
    IN  HANDLE  ThreadHandle,
    OUT PULONG  PreviousSuspendCount OPTIONAL
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(ThreadHandle)
		LOG_FUNC_ARG_OUT(PreviousSuspendCount)
		LOG_FUNC_END;

    NTSTATUS ret = NtDll::NtSuspendThread(ThreadHandle, PreviousSuspendCount);

	return ret;
}

// ******************************************************************
// * 0x00E8 - NtUserIoApcDispatcher
// ******************************************************************
XBSYSAPI EXPORTNUM(232) VOID NTAPI xboxkrnl::NtUserIoApcDispatcher
(
    PVOID            ApcContext,
    PIO_STATUS_BLOCK IoStatusBlock,
    ULONG            Reserved
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(ApcContext)
		LOG_FUNC_ARG(IoStatusBlock)
		LOG_FUNC_ARG(Reserved)
		LOG_FUNC_END;

    uint32 dwEsi, dwEax, dwEcx;

    dwEsi = (uint32)IoStatusBlock;

    if((IoStatusBlock->u1.Status & 0xC0000000) == 0xC0000000)
    {
        dwEcx = 0;
        dwEax = NtDll::RtlNtStatusToDosError(IoStatusBlock->u1.Status);
    }
    else
    {
        dwEcx = (DWORD)IoStatusBlock->Information;
        dwEax = 0;
    }

    /*
    // ~XDK 3911??
    if(true)
    {
        dwEsi = dw2;
        dwEcx = dw1;
        dwEax = dw3;

    }
    else
    {
        dwEsi = dw1;
        dwEcx = dw2;
        dwEax = dw3;
    }//*/

    __asm
    {
        pushad
        /*
        mov esi, IoStatusBlock
        mov ecx, dwEcx
        mov eax, dwEax
        */
        // TODO: Figure out if/why this works!? Matches prototype, but not xboxkrnl disassembly
        // Seems to be XDK/version dependand??
        mov esi, dwEsi
        mov ecx, dwEcx
        mov eax, dwEax

        push esi
        push ecx
        push eax

        call ApcContext

        popad
    }
	
	DbgPrintf("EmuKrnl (0x%X): NtUserIoApcDispatcher Completed\n", GetCurrentThreadId());

    return;
}

// ******************************************************************
// * 0x00EA - NtWaitForSingleObjectEx
// ******************************************************************
XBSYSAPI EXPORTNUM(234) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtWaitForSingleObjectEx
(
    IN  HANDLE          Handle,
    IN  CHAR            WaitMode,
    IN  BOOLEAN         Alertable,
    IN  PLARGE_INTEGER  Timeout
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(Handle)
		LOG_FUNC_ARG(WaitMode)
		LOG_FUNC_ARG(Alertable)
		LOG_FUNC_ARG(Timeout)
		LOG_FUNC_END;

	NTSTATUS ret;

	if (IsEmuHandle(Handle))
	{
		ret = WAIT_FAILED;
		EmuWarning("WaitFor EmuHandle not supported!");
	}
	else
	{
		ret = NtDll::NtWaitForSingleObject(Handle, Alertable, (NtDll::PLARGE_INTEGER)Timeout);
		DbgPrintf("Finished waiting for 0x%.08X\n", Handle);
	}
    
	if (ret == WAIT_FAILED) 
		EmuWarning("NtWaitForSingleObjectEx failed! (%s)", NtStatusToString(ret));

	return ret;
}

// ******************************************************************
// * NtWaitForMultipleObjectsEx
// ******************************************************************
XBSYSAPI EXPORTNUM(235) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtWaitForMultipleObjectsEx
(
    IN  ULONG           Count,
    IN  HANDLE         *Handles,
    IN  WAIT_TYPE       WaitType,
    IN  CHAR            WaitMode,
    IN  BOOLEAN         Alertable,
    IN  PLARGE_INTEGER  Timeout
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(Count)
		LOG_FUNC_ARG(Handles)
		LOG_FUNC_ARG(WaitType)
		LOG_FUNC_ARG(WaitMode)
		LOG_FUNC_ARG(Alertable)
		LOG_FUNC_ARG(Timeout)
		LOG_FUNC_END;

	// TODO: Process EmuHandle
    NTSTATUS ret = NtDll::NtWaitForMultipleObjects(Count, Handles, (NtDll::OBJECT_WAIT_TYPE)WaitType, Alertable, (NtDll::PLARGE_INTEGER)Timeout);

	return ret;
}

// ******************************************************************
// * 0x00EC - NtWriteFile
// ******************************************************************
XBSYSAPI EXPORTNUM(236) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtWriteFile
(
    IN  HANDLE          FileHandle,            // TODO: correct paramters
    IN  PVOID           Event,
    IN  PVOID           ApcRoutine,
    IN  PVOID           ApcContext,
    OUT PVOID           IoStatusBlock,
    IN  PVOID           Buffer,
    IN  ULONG           Length,
    IN  PLARGE_INTEGER  ByteOffset
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(FileHandle)
		LOG_FUNC_ARG(Event)
		LOG_FUNC_ARG(ApcRoutine)
		LOG_FUNC_ARG(ApcContext)
		LOG_FUNC_ARG_OUT(IoStatusBlock)
		LOG_FUNC_ARG(Buffer)
		LOG_FUNC_ARG(Length)
		LOG_FUNC_ARG(ByteOffset)
		LOG_FUNC_END;

// Halo..
//    if(ByteOffset != 0 && ByteOffset->QuadPart == 0x01C00800)
//        _asm int 3

    NTSTATUS ret = NtDll::NtWriteFile(FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, Buffer, Length, (NtDll::LARGE_INTEGER*)ByteOffset, 0);

    if(FAILED(ret))
        EmuWarning("NtWriteFile Failed! (0x%.08X)", ret);

	return ret;
}

// ******************************************************************
// * 0x00EE - NtYieldExecution
// ******************************************************************
XBSYSAPI EXPORTNUM(238) VOID NTAPI xboxkrnl::NtYieldExecution()
{
	// NOTE: this eats up the debug log far too quickly
    //LOG_FUNC();

    NtDll::NtYieldExecution();

	return;
}

// ******************************************************************
// * 0x00FF - PsCreateSystemThreadEx
// ******************************************************************
XBSYSAPI EXPORTNUM(255) xboxkrnl::NTSTATUS NTAPI xboxkrnl::PsCreateSystemThreadEx
(
    OUT PHANDLE         ThreadHandle,
    IN  ULONG           ThreadExtraSize,
    IN  ULONG           KernelStackSize,
    IN  ULONG           TlsDataSize,
    OUT PULONG          ThreadId OPTIONAL,
    IN  PVOID           StartContext1,
    IN  PVOID           StartContext2,
    IN  BOOLEAN         CreateSuspended,
    IN  BOOLEAN         DebugStack,
    IN  PKSTART_ROUTINE StartRoutine
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG_OUT(ThreadHandle)
		LOG_FUNC_ARG(ThreadExtraSize)
		LOG_FUNC_ARG(KernelStackSize)
		LOG_FUNC_ARG(TlsDataSize)
		LOG_FUNC_ARG_OUT(ThreadId)
		LOG_FUNC_ARG(StartContext1)
		LOG_FUNC_ARG(StartContext2)
		LOG_FUNC_ARG(CreateSuspended)
		LOG_FUNC_ARG(DebugStack)
		LOG_FUNC_ARG(StartRoutine)
		LOG_FUNC_END;

	static bool bFirstTime = false;

    // create thread, using our special proxy technique
    {
        DWORD dwThreadId;

        // PCSTProxy is responsible for cleaning up this pointer
        ::PCSTProxyParam *iPCSTProxyParam = new ::PCSTProxyParam();

        iPCSTProxyParam->StartContext1 = StartContext1;
        iPCSTProxyParam->StartContext2 = StartContext2;
        iPCSTProxyParam->StartRoutine  = StartRoutine;
        iPCSTProxyParam->StartSuspended = CreateSuspended;
        iPCSTProxyParam->hStartedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        *ThreadHandle = (HANDLE)_beginthreadex(NULL, NULL, PCSTProxy, iPCSTProxyParam, NULL, (uint*)&dwThreadId);

		// Make sure Xbox1 code runs on one core :
		SetThreadAffinityMask(ThreadHandle, g_CPUXbox);

        WaitForSingleObject(iPCSTProxyParam->hStartedEvent, 1000);

//        *ThreadHandle = CreateThread(NULL, NULL, PCSTProxy, iPCSTProxyParam, NULL, &dwThreadId);

        DbgPrintf("EmuKrnl (0x%X): ThreadHandle : 0x%X, ThreadId : 0x%.08X\n", GetCurrentThreadId(), *ThreadHandle, dwThreadId);

        // we must duplicate this handle in order to retain Suspend/Resume thread rights from a remote thread
        {
            HANDLE hDupHandle = NULL;

            DuplicateHandle(GetCurrentProcess(), *ThreadHandle, GetCurrentProcess(), &hDupHandle, 0, FALSE, DUPLICATE_SAME_ACCESS);

            CxbxKrnlRegisterThread(hDupHandle);
        }

        if(ThreadId != NULL)
            *ThreadId = dwThreadId;
    }

	return STATUS_SUCCESS;
}

// ******************************************************************
// * 0x0102 - PsTerminateSystemThread
// ******************************************************************
XBSYSAPI EXPORTNUM(258) VOID NTAPI xboxkrnl::PsTerminateSystemThread
(
	IN NTSTATUS ExitStatus
)
{
	LOG_FUNC_ONE_ARG(ExitStatus);

    // call thread notification routine(s)
    if(g_iThreadNotificationCount != 0)
    {
		for(int i = 0; i < 16; i++ )
		{
			XTL::XTHREAD_NOTIFY_PROC pfnNotificationRoutine = (XTL::XTHREAD_NOTIFY_PROC)g_pfnThreadNotification[i];

			// If the routine doesn't exist, don't execute it!
			if(pfnNotificationRoutine == NULL)
				continue;

			DbgPrintf("EmuKrnl (0x%X): Calling pfnNotificationRoutine[%d] (0x%.08X)\n", GetCurrentThreadId(), g_iThreadNotificationCount, pfnNotificationRoutine);

			pfnNotificationRoutine(FALSE);
		}
    }

//    CxbxKrnlTerminateThread();

    EmuCleanupFS();

    _endthreadex(ExitStatus);
    //ExitThread(ExitStatus);

    return;
}

// ******************************************************************
// * 0x0104 - RtlAnsiStringToUnicodeString
// ******************************************************************
XBSYSAPI EXPORTNUM(260) xboxkrnl::NTSTATUS NTAPI xboxkrnl::RtlAnsiStringToUnicodeString
(
    PUNICODE_STRING DestinationString,
    PSTRING         SourceString,
    UCHAR           AllocateDestinationString
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(DestinationString)
		LOG_FUNC_ARG(SourceString)
		LOG_FUNC_ARG(AllocateDestinationString)
		LOG_FUNC_END;

    NTSTATUS ret = NtDll::RtlAnsiStringToUnicodeString((NtDll::UNICODE_STRING*)DestinationString, (NtDll::STRING*)SourceString, AllocateDestinationString);

	return ret;
}

// ******************************************************************
// * 0x0108 - RtlAssert - Debug API?
// ******************************************************************
XBSYSAPI EXPORTNUM(264) VOID NTAPI xboxkrnl::RtlAssert
(
    PVOID   FailedAssertion, // PCHAR
    PVOID   FileName, // PCHAR
    ULONG   LineNumber,
    PCHAR   Message
)
{
	LOG_FUNC_BEGIN 
		LOG_FUNC_ARG(FailedAssertion)
		LOG_FUNC_ARG(FileName)
		LOG_FUNC_ARG(LineNumber)
		LOG_FUNC_ARG(Message)
		LOG_FUNC_END;

    CxbxKrnlCleanup("RtlAssert() raised by emulated program - consult Debug log");

	return;
}

// ******************************************************************
// * 0x0115 RtlEnterCriticalSection
// ******************************************************************
XBSYSAPI EXPORTNUM(277) VOID NTAPI xboxkrnl::RtlEnterCriticalSection
(
  IN PRTL_CRITICAL_SECTION CriticalSection
)
{
    /** sorta pointless
    LOG_FUNC_ONE_ARG(CriticalSection);
    //*/

    //printf("CriticalSection->LockCount : %d\n", CriticalSection->LockCount);

	// This seems redundant, but xbox software doesn't always do it
	if (CriticalSection)
	{
		int iSection = FindCriticalSection(CriticalSection);

		if (iSection >= 0)
		{
			GlobalCriticalSections[iSection].XboxCriticalSection = CriticalSection;
			if (CriticalSection->LockCount < 0)
				NtDll::RtlInitializeCriticalSection(&GlobalCriticalSections[iSection].NativeCriticalSection);

			NtDll::RtlEnterCriticalSection(&GlobalCriticalSections[iSection].NativeCriticalSection);

			CriticalSection->LockCount = GlobalCriticalSections[iSection].NativeCriticalSection.LockCount;
			CriticalSection->RecursionCount = GlobalCriticalSections[iSection].NativeCriticalSection.RecursionCount;
			CriticalSection->OwningThread = GlobalCriticalSections[iSection].NativeCriticalSection.OwningThread;
		}
		
		//if(CriticalSection->LockCount == -1)
			//NtDll::RtlInitializeCriticalSection((NtDll::_RTL_CRITICAL_SECTION*)CriticalSection);

		//NtDll::RtlEnterCriticalSection((NtDll::_RTL_CRITICAL_SECTION*)CriticalSection);
	}

	return;
}

// ******************************************************************
// * 0x0117 - RtlEqualString
// ******************************************************************
XBSYSAPI EXPORTNUM(279) xboxkrnl::BOOLEAN NTAPI xboxkrnl::RtlEqualString
(
  IN PSTRING String1,
  IN PSTRING String2,
  IN BOOLEAN CaseSensitive
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(String1)
		LOG_FUNC_ARG(String2)
		LOG_FUNC_ARG(CaseSensitive)
		LOG_FUNC_END;

	BOOLEAN bRet = NtDll::RtlEqualString( (NtDll::PSTRING)String1, (NtDll::PSTRING)String2, (NtDll::BOOLEAN)CaseSensitive );

	return bRet;
}

// ******************************************************************
// * 0x011E - RtlFreeAnsiString
// ******************************************************************
XBSYSAPI EXPORTNUM(286) VOID NTAPI xboxkrnl::RtlFreeAnsiString
(
  IN OUT PANSI_STRING AnsiString
)
{
	LOG_FUNC_ONE_ARG(AnsiString);

    NtDll::RtlFreeAnsiString((NtDll::PANSI_STRING)AnsiString);

	return;
}

// ******************************************************************
// * 0x0121 - RtlInitAnsiString
// ******************************************************************
XBSYSAPI EXPORTNUM(289) VOID NTAPI xboxkrnl::RtlInitAnsiString
(
  IN OUT PANSI_STRING DestinationString,
  IN     PCSZ         SourceString
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG_OUT(DestinationString)
		LOG_FUNC_ARG(SourceString)
		LOG_FUNC_END;

    NtDll::RtlInitAnsiString((NtDll::PANSI_STRING)DestinationString, (NtDll::PCSZ)SourceString);

	return;
}

// ******************************************************************
// * 0x0122 - RtlInitUnicodeString
// ******************************************************************
XBSYSAPI EXPORTNUM(290) VOID NTAPI xboxkrnl::RtlInitUnicodeString
(
  IN OUT PUNICODE_STRING DestinationString,
  IN     PSTRING         SourceString
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG_OUT(DestinationString)
		LOG_FUNC_ARG(SourceString)
		LOG_FUNC_END;

    NtDll::RtlInitUnicodeString((NtDll::PUNICODE_STRING)DestinationString, (NtDll::PCWSTR)SourceString);

	return;
}

// ******************************************************************
// * 0x0123 - RtlInitializeCriticalSection
// ******************************************************************
XBSYSAPI EXPORTNUM(291) VOID NTAPI xboxkrnl::RtlInitializeCriticalSection
(
  IN PRTL_CRITICAL_SECTION CriticalSection
)
{
	if (CriticalSection == nullptr) {
		return;
	}

    /*
    LOG_FUNC_ONE_ARG(CriticalSection);
    //*/
	int iSection = FindCriticalSection(CriticalSection);

	if (iSection >= 0)
	{
		GlobalCriticalSections[iSection].XboxCriticalSection = CriticalSection;
		NtDll::RtlInitializeCriticalSection(&GlobalCriticalSections[iSection].NativeCriticalSection);

		CriticalSection->LockCount = GlobalCriticalSections[iSection].NativeCriticalSection.LockCount;
		CriticalSection->RecursionCount = GlobalCriticalSections[iSection].NativeCriticalSection.RecursionCount;
		CriticalSection->OwningThread = GlobalCriticalSections[iSection].NativeCriticalSection.OwningThread;
	}

	//NtDll::RtlInitializeCriticalSection((NtDll::_RTL_CRITICAL_SECTION*)CriticalSection);

	return;
}

// ******************************************************************
// * 0x0126 RtlEnterCriticalSection
// ******************************************************************
XBSYSAPI EXPORTNUM(294) VOID NTAPI xboxkrnl::RtlLeaveCriticalSection
(
  IN PRTL_CRITICAL_SECTION CriticalSection
)
{
	if (CriticalSection == nullptr) {
		return;
	}

	int iSection = FindCriticalSection(CriticalSection);

	if (iSection >= 0)
	{
		GlobalCriticalSections[iSection].XboxCriticalSection = CriticalSection;
		NtDll::RtlLeaveCriticalSection(&GlobalCriticalSections[iSection].NativeCriticalSection);

		CriticalSection->LockCount = GlobalCriticalSections[iSection].NativeCriticalSection.LockCount;
		CriticalSection->RecursionCount = GlobalCriticalSections[iSection].NativeCriticalSection.RecursionCount;
		CriticalSection->OwningThread = GlobalCriticalSections[iSection].NativeCriticalSection.OwningThread;
	}
	// Note: We need to execute this before debug output to avoid trouble
	//NtDll::RtlLeaveCriticalSection((NtDll::_RTL_CRITICAL_SECTION*)CriticalSection);

    /* sorta pointless
    LOG_FUNC_ONE_ARG(CriticalSection);
    //*/

	return;
}

// ******************************************************************
// * RtlLowerChar
// ******************************************************************
XBSYSAPI EXPORTNUM(296) xboxkrnl::CHAR NTAPI xboxkrnl::RtlLowerChar
(
	CHAR Character
)
{
	LOG_FUNC_ONE_ARG(Character);

    CHAR ret = tolower(Character);

    return ret;
}

// ******************************************************************
// * 0x012D - RtlNtStatusToDosError
// ******************************************************************
XBSYSAPI EXPORTNUM(301) xboxkrnl::ULONG NTAPI xboxkrnl::RtlNtStatusToDosError
(
    IN NTSTATUS Status
)
{
	LOG_FUNC_ONE_ARG(Status);

    ULONG ret = NtDll::RtlNtStatusToDosError(Status);

	return ret;
}

// ******************************************************************
// * 0x0130 - RtlTimeFieldsToTime
// ******************************************************************
XBSYSAPI EXPORTNUM(304) xboxkrnl::BOOLEAN NTAPI xboxkrnl::RtlTimeFieldsToTime
(
    IN  PTIME_FIELDS    TimeFields,
    OUT PLARGE_INTEGER  Time
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(TimeFields)
		LOG_FUNC_ARG_OUT(Time)
		LOG_FUNC_END;

    BOOLEAN bRet = NtDll::RtlTimeFieldsToTime((NtDll::TIME_FIELDS*)TimeFields, (NtDll::LARGE_INTEGER*)Time);

	return bRet;
}

// ******************************************************************
// * 0x0131 - RtlTimeToTimeFields
// ******************************************************************
XBSYSAPI EXPORTNUM(305) VOID NTAPI xboxkrnl::RtlTimeToTimeFields
(
    IN  PLARGE_INTEGER  Time,
    OUT PTIME_FIELDS    TimeFields
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(Time)
		LOG_FUNC_ARG_OUT(TimeFields)
		LOG_FUNC_END;

    NtDll::RtlTimeToTimeFields((NtDll::LARGE_INTEGER*)Time, (NtDll::TIME_FIELDS*)TimeFields);

	return;
}

// ******************************************************************
// * RtlTryEnterCriticalSection
// ******************************************************************
XBSYSAPI EXPORTNUM(306) xboxkrnl::BOOLEAN NTAPI xboxkrnl::RtlTryEnterCriticalSection
(
    IN PRTL_CRITICAL_SECTION CriticalSection
)
{
	// Return on nullptr BEFORE logging!
	if (CriticalSection == nullptr) {
		return false;
	}

	LOG_FUNC_ONE_ARG(CriticalSection);

	BOOL bRet = FALSE;
	
	int iSection = FindCriticalSection(CriticalSection);

	if (iSection >= 0)
	{
		GlobalCriticalSections[iSection].XboxCriticalSection = CriticalSection;
		if (CriticalSection->LockCount < 0)
			NtDll::RtlInitializeCriticalSection(&GlobalCriticalSections[iSection].NativeCriticalSection);

		bRet = NtDll::RtlTryEnterCriticalSection(&GlobalCriticalSections[iSection].NativeCriticalSection);

		CriticalSection->LockCount = GlobalCriticalSections[iSection].NativeCriticalSection.LockCount;
		CriticalSection->RecursionCount = GlobalCriticalSections[iSection].NativeCriticalSection.RecursionCount;
		CriticalSection->OwningThread = GlobalCriticalSections[iSection].NativeCriticalSection.OwningThread;
	}

	//bRet = NtDll::RtlTryEnterCriticalSection((NtDll::PRTL_CRITICAL_SECTION)CriticalSection);

	return bRet;
}

// ******************************************************************
// * 0x0134 - RtlUnicodeStringToAnsiString
// ******************************************************************
XBSYSAPI EXPORTNUM(308) xboxkrnl::NTSTATUS NTAPI xboxkrnl::RtlUnicodeStringToAnsiString
(
    IN OUT PSTRING         DestinationString,
    IN     PUNICODE_STRING SourceString,
    IN     BOOLEAN         AllocateDestinationString
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG_OUT(DestinationString)
		LOG_FUNC_ARG(SourceString)
		LOG_FUNC_ARG(AllocateDestinationString)
		LOG_FUNC_END;
	
    NTSTATUS ret = NtDll::RtlUnicodeStringToAnsiString((NtDll::STRING*)DestinationString, (NtDll::UNICODE_STRING*)SourceString, AllocateDestinationString);

	return ret;
}



// ******************************************************************
// * 0x0142 - XboxHardwareInfo
// ******************************************************************
XBSYSAPI EXPORTNUM(322) XBOX_HARDWARE_INFO xboxkrnl::XboxHardwareInfo =
{
    0xC0000035,
    0,0,0,0
};

// ******************************************************************
// * 0x0143 - XboxHDKey
// ******************************************************************
XBSYSAPI EXPORTNUM(323) xboxkrnl::UCHAR xboxkrnl::XboxHDKey[16] =
{
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
};


// ******************************************************************
// * 0x0144 - XboxKrnlVersion
// ******************************************************************
XBSYSAPI EXPORTNUM(324) xboxkrnl::XBOX_KRNL_VERSION xboxkrnl::XboxKrnlVersion =
{
	1, 0, 5838, 1
};



// ******************************************************************
// * XboxSignatureKey
// ******************************************************************
XBSYSAPI EXPORTNUM(325) xboxkrnl::BYTE xboxkrnl::XboxSignatureKey[16] =
{
    // cxbx default saved game key
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


// ******************************************************************
// * XeImageFileName
// ******************************************************************
XBSYSAPI EXPORTNUM(326) xboxkrnl::OBJECT_STRING xboxkrnl::XeImageFileName = 
{

};

XBSYSAPI EXPORTNUM(327) xboxkrnl::NTSTATUS NTAPI xboxkrnl::XeLoadSection
(
	void* section
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(section)
		LOG_FUNC_END;

	if (((Xbe::SectionHeader*)section)->dwSectionRefCount > 0) {
		((Xbe::SectionHeader*)section)->dwSectionRefCount++;
		return STATUS_SUCCESS;
	}

	EmuWarning("XeLoadSection lied");

	return STATUS_SUCCESS;
}

XBSYSAPI EXPORTNUM(328) xboxkrnl::NTSTATUS NTAPI xboxkrnl::XeUnloadSection
(
	void* section
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(section)
		LOG_FUNC_END;

	if (((Xbe::SectionHeader*)section)->dwSectionRefCount == 0) {
		return STATUS_INVALID_PARAMETER;
	}

	EmuWarning("XeUnloadSection lied");

	return STATUS_SUCCESS;
}

// ******************************************************************
// * XcSHAInit
// ******************************************************************
XBSYSAPI EXPORTNUM(335) VOID NTAPI xboxkrnl::XcSHAInit
(
	UCHAR *pbSHAContext
)
{
	LOG_FUNC_ONE_ARG(pbSHAContext);

	return;
}

// ******************************************************************
// * XcSHAUpdate
// ******************************************************************
XBSYSAPI EXPORTNUM(336) VOID NTAPI xboxkrnl::XcSHAUpdate
(
	UCHAR *pbSHAContext, 
	UCHAR *pbInput, 
	ULONG dwInputLength
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(pbSHAContext)
		LOG_FUNC_ARG(pbInput)
		LOG_FUNC_ARG(dwInputLength)
		LOG_FUNC_END;

	return;
}

// ******************************************************************
// * XcSHAFinal
// ******************************************************************
XBSYSAPI EXPORTNUM(337) VOID NTAPI xboxkrnl::XcSHAFinal
(
	UCHAR *pbSHAContext, 
	UCHAR *pbDigest
)
{
	LOG_FUNC_BEGIN
		LOG_FUNC_ARG(pbSHAContext)
		LOG_FUNC_ARG(pbDigest)
		LOG_FUNC_END;

    // for now, we dont care about the digest
    for(int v=0;v<20;v++)
    {
        pbDigest[v] = 0;
    }

	return;
}

// ******************************************************************
// * HalBootSMCVideoMode
// ******************************************************************
// TODO: Verify this!
XBSYSAPI EXPORTNUM(356) xboxkrnl::DWORD xboxkrnl::HalBootSMCVideoMode = 1;
